<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>REAKTOR 404 — Cleaners Run</title>
<meta name="theme-color" content="#0b0b0b" />
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Doto:wght@400..900&family=Sixtyfour+Convergence:SCAN@-45..45&display=swap" rel="stylesheet" />
<!-- Base -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>REAKTOR 404 — Cleaners Run</title>
<meta name="description" content="Top-down arcade maze: outrun Cleaners, grab SEALS, pop an IsoSpark for invincibility, and bolt to the exit. Fast, punchy, CRT-glow chaos." />
<link rel="canonical" href="https://ironsignalworks.github.io/reaktor404/" />

<!-- Theming -->
<meta name="theme-color" content="#0b0b0b" />
<meta name="color-scheme" content="dark light" />

<!-- Robots -->
<meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1" />
<meta name="googlebot" content="index,follow" />

<!-- Preconnect / Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Doto:wght@400..900&family=Sixtyfour+Convergence:SCAN@-45..45&display=swap" rel="stylesheet" />

<!-- Icons / PWA (update paths if different) -->
<link rel="icon" href="/reaktor404/favicon.ico" sizes="any" />
<link rel="icon" href="/reaktor404/icon.svg" type="image/svg+xml" />
<link rel="apple-touch-icon" href="/reaktor404/apple-touch-icon.png" />
<link rel="manifest" href="/reaktor404/site.webmanifest" />
<link rel="mask-icon" href="/reaktor404/safari-pinned-tab.svg" color="#0b0b0b" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="REAKTOR 404" />
<meta name="application-name" content="REAKTOR 404" />
<meta name="msapplication-TileColor" content="#0b0b0b" />

<!-- Open Graph -->
<meta property="og:title" content="REAKTOR 404 — Cleaners Run" />
<meta property="og:description" content="Top-down arcade maze: outrun Cleaners, snatch SEALS, hit IsoSpark, and escape. CRT-glow chaos." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ironsignalworks.github.io/reaktor404/" />
<meta property="og:site_name" content="Iron Signal Works" />
<meta property="og:image" content="https://ironsignalworks.github.io/reaktor404/card.jpg" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:alt" content="REAKTOR 404 — green blob dodging red Cleaners in a neon maze" />
<meta property="og:locale" content="en_US" />

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="REAKTOR 404 — Cleaners Run" />
<meta name="twitter:description" content="Outrun Cleaners, collect SEALS, trigger IsoSpark, reach the exit. Fast CRT-arcade action." />
<meta name="twitter:image" content="https://ironsignalworks.github.io/reaktor404/card.jpg" />
<meta name="twitter:image:alt" content="REAKTOR 404 — green blob dodging red Cleaners in a neon maze" />
<!-- <meta name="twitter:site" content="@IronSignalWorks" /> -->

<!-- Optional: keywords/author -->
<meta name="author" content="Iron Signal Works" />
<meta name="keywords" content="reaktor 404, cleaners run, iron signal works, arcade maze, browser game, pixel, crt" />

<!-- JSON-LD (schema.org VideoGame) -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "REAKTOR 404 — Cleaners Run",
  "url": "https://ironsignalworks.github.io/reaktor404/",
  "image": "https://ironsignalworks.github.io/reaktor404/card.jpg",
  "description": "Top-down arcade maze where you dodge Cleaners, collect SEALS, trigger IsoSpark invincibility, and sprint for the exit.",
  "inLanguage": "en",
  "operatingSystem": "Web",
  "applicationCategory": "Game",
  "genre": ["Arcade", "Action"],
  "author": {
    "@type": "Organization",
    "name": "Iron Signal Works"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Iron Signal Works"
  }
}
</script>

<style>
:root{
  --bg:#050607; --ink:#e9f0f1; --accent:#3dff7a; --haz:#ffcc00; --danger:#ff4d4d; --iso:#4be3ff;
  --bevel-top:rgba(255,255,255,.1); --bevel-bottom:rgba(0,0,0,.5);
}
*{box-sizing:border-box}
html,body{height:100%; margin:0}
body{
  min-height:100dvh; background:var(--bg); color:var(--ink);
  font-family:"Doto",system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
}

/* Header — fixed, left-aligned, no movement */
.header{
  position:fixed; left:0; right:0; top:0;
  display:flex; align-items:center; justify-content:flex-start; gap:16px;
  padding:8px 10px;
  border-bottom:1px solid rgba(255,255,255,.08);
  background:linear-gradient(180deg,#12161a,#0a0d10);
  z-index:5;
}
.header-spacer{ height:44px; } /* keep layout from sliding under bar */

.brand{ font-weight:800; letter-spacing:.08em; opacity:.9; font-size: 18px; text-transform:uppercase }
.title{ font-weight:800; letter-spacing:.06em; text-transform:uppercase; font-size:18px; opacity:.95; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; flex:1; text-align:center; }
.controls{ margin-left:auto; display:flex; gap:8px; align-items:center; flex-shrink:0 }
.mini-btn{
  -webkit-appearance:none; appearance:none; border:0; cursor:pointer;
  padding:8px 12px; border-radius:10px; color:var(--ink); font-weight:900; letter-spacing:.06em; text-transform:uppercase; font-size:12px;
  background:linear-gradient(145deg,rgba(255,255,255,.08),rgba(0,0,0,.35));
  box-shadow:inset 2px 2px 0 var(--bevel-top), inset -2px -2px 0 var(--bevel-bottom);
}

/* Screen */
.screen{ display:grid; place-items:center; padding:8px; }
canvas{
  display:block; width:100%; height:100%;
  max-width:min(96vmin, 100vw - 16px);
  max-height:calc(100vh - 120px);
  aspect-ratio:1/1;
  background:#050607; border-radius:10px;
  image-rendering:pixelated;
  box-shadow:inset 0 0 0 2px rgba(255,255,255,.06);
  transition:box-shadow .25s ease, filter .25s ease;
}
/* Cabinet glow while IsoSpark is active */
canvas.glow{
  animation:cabGlow 1.4s ease-in-out infinite alternate;
  box-shadow:
    0 0 14px rgba(75,227,255,.45),
    0 0 44px rgba(75,227,255,.35),
    inset 0 0 0 2px rgba(255,255,255,.12),
    inset 0 0 22px rgba(75,227,255,.15);
  filter: saturate(1.25);
}
@keyframes cabGlow{
  0%{ box-shadow:0 0 10px rgba(75,227,255,.35),0 0 28px rgba(75,227,255,.25),inset 0 0 0 2px rgba(255,255,255,.12),inset 0 0 14px rgba(75,227,255,.10) }
  100%{ box-shadow:0 0 22px rgba(75,227,255,.55),0 0 60px rgba(75,227,255,.45),inset 0 0 0 2px rgba(255,255,255,.12),inset 0 0 24px rgba(75,227,255,.18) }
}

/* Joystick */
.stick-wrap{ display:none; padding:10px }
@media (hover:none) and (pointer:coarse){ .stick-wrap{ display:grid; place-items:center } }
.stick{
  width:min(56vw,220px); aspect-ratio:1/1; border-radius:50%;
  background:radial-gradient(120px 120px at 50% 45%, rgba(255,255,255,.06), rgba(0,0,0,.55));
  box-shadow: inset 2px 2px 0 rgba(255,255,255,.07), inset -2px -2px 0 rgba(0,0,0,.6), 0 8px 18px rgba(0,0,0,.35);
  position:relative; touch-action:none;
}
.stick::before{ content:""; position:absolute; inset:12%; border-radius:50%; border:1px dashed rgba(255,255,255,.18) }
.stick::after{ content:""; position:absolute; left:50%; top:50%; width:34%; aspect-ratio:1/1; border-radius:50%;
  transform:translate(-50%,-50%); background:linear-gradient(145deg, rgba(255,255,255,.08), rgba(0,0,0,.55));
  box-shadow: inset 2px 2px 0 rgba(255,255,255,.08), inset -2px -2px 0 rgba(0,0,0,.6);
}

/* Overlays */
.veil{ position:fixed; inset:0; background:rgba(0,0,0,.65); display:none; backdrop-filter:saturate(.8) blur(2px); z-index:98 }
.cta{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%) scale(.92);
  text-align:center; z-index:99; width:min(92%,560px); padding: clamp(20px, 6vw, 36px) 8px;
}
.cta .title{
  font-family:"Sixtyfour Convergence",system-ui; font-weight:800; font-size:clamp(38px,6vw,40px);
  line-height:1.06; letter-spacing:.04em; text-transform:uppercase; text-align: center;
}
.cta .subtitle{ opacity:.95; margin-top:10px; font-size:clamp(12px,3.6vw,16px); line-height:1.35; text-align:center }
.btn{
  display:inline-block; padding:12px 18px; min-height:44px; border-radius:12px; font-size:18px; font-weight:800; letter-spacing:.06em; text-transform:uppercase; color:var(--ink);
  background:linear-gradient(145deg,rgba(255,255,255,.08),rgba(0,0,0,.35));
  box-shadow:inset 2px 2px 0 var(--bevel-top), inset -2px -2px 0 var(--bevel-bottom);
  text-decoration:none;
}
.btn-row{ display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap }

.countdown{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; pointer-events:none; z-index:100 }
.countdown .num{ font:900 64px/1 "Doto",system-ui; letter-spacing:.06em; text-shadow:0 0 18px rgba(255,211,77,.45) }

/* Map modal */
.cta.cta--map{ width:min(96vw,900px); max-height:86vh; overflow:auto; text-align:left; background:#000; border:1px solid rgba(255,255,255,.12); padding:0 8px }
.mapwrap{ padding:12px 0 6px; background:#000 }
.maphead{ display:flex; align-items:center; justify-content:space-between; gap:12px; position:sticky; top:0; background:#000; padding:10px 6px 8px; border-bottom:1px solid rgba(255,255,255,.16); z-index:1 }
.maptitle{ font-family:"Sixtyfour Convergence",system-ui; font-weight:800; font-size:18px; letter-spacing:.06em; text-transform:uppercase }
.maptable{ width:100%; border-collapse:collapse; font-size:14px; background:#000; table-layout:fixed }
.maptable th{ text-align:left; font-weight:900; letter-spacing:.06em; text-transform:uppercase; opacity:.85; padding:10px 12px; font-size:12px; border-bottom:1px solid rgba(255,255,255,.16) }
.mapcell{ padding:10px 12px; vertical-align:top; border-bottom:1px solid rgba(255,255,255,.08); overflow-wrap:anywhere; word-break:break-word }
.maprank{ width:3.5ch; font-weight:900; text-align:center } .mapdanger{ width:7ch } .maploc{ font-weight:800 } .mapnotes{ opacity:.92 }

/* Footer */
.siteFooter{
  position:fixed; left:50%; bottom:max(10px, calc(8px + env(safe-area-inset-bottom, 0px)));
  transform:translateX(-50%); z-index:100; display:none;
}
.siteFooter a{
  display:inline-flex; align-items:center; gap:10px; padding:8px 12px; border-radius:999px; text-decoration:none; color:var(--ink);
  font-weight:800; letter-spacing:.02em; background:linear-gradient(145deg,rgba(255,255,255,.06),rgba(0,0,0,.35));
  box-shadow:inset 2px 2px 0 var(--bevel-top), inset -2px -2px 0 var(--bevel-bottom);
  backdrop-filter:blur(4px) saturate(1.1);
}
.siteFooter img{ width:20px; height:20px; object-fit:contain; display:block }
.siteFooter span{ font-size:12px; white-space:nowrap }
@media(max-width:420px){ .siteFooter span{ display:none } .siteFooter a{ padding:9px 10px } }

/* Hidden live regions */
#status{ position:absolute; width:1px; height:1px; overflow:hidden; clip:rect(0 0 0 0); white-space:nowrap; border:0; }
</style>
</head>
<body>
  <!-- Header (fixed) -->
  <header class="header" id="cabTop">
    <div class="brand">REAKTOR 404</div>
    <div class="title">Level: <span id="levelName">Rank 1 — Fission Gardens</span></div>
    <div class="controls">
      <button class="mini-btn" id="mapBtn" type="button">Map</button>
      <button class="mini-btn" id="helpBtn" type="button">Pause/Info</button>
      <button class="mini-btn" id="muteBtn" type="button" aria-pressed="false" title="Mute / Unmute">🔊</button>
    </div>
  </header>
  <div class="header-spacer" aria-hidden="true"></div>

  <!-- Screen -->
  <main class="screen" id="cabScreen">
    <canvas id="board" width="960" height="960" aria-label="Game board"></canvas>
  </main>

  <!-- Mobile joystick -->
  <div class="stick-wrap" id="cabControls">
    <div class="stick" id="stick" aria-label="Joystick" role="slider" aria-valuemin="-1" aria-valuemax="1" aria-valuenow="0"></div>
  </div>

  <!-- OVERLAYS -->
  <div class="veil" id="veil"></div>

  <div class="cta cta--menu" id="menu">
    <div class="title" id="menuTitle">REAKTOR 404</div>
    <div class="subtitle" id="menuSub">
      You are a sentient radioactive blob sent by grocery clerks to collect the bill.
      Collect <b>SEALS</b> for bonus points, snag an <b>IsoSpark</b> to go invincible, and bolt for the exit. Avoid the Cleaners.
    </div>
    <div class="btn-row"><a class="btn" href="#" id="play">Start</a></div>
  </div>

  <div class="cta cta--map" id="mapModal" style="display:none;">
    <div class="mapwrap">
      <div class="maphead">
        <div class="maptitle">☢️ Radioactive Danger</div>
        <button class="mini-btn" id="mapClose" type="button">Close</button>
      </div>
      <table class="maptable" id="mapTable">
        <thead><tr><th>Rank</th><th>Location</th><th>Danger</th><th>Notes</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="cta cta--map" id="helpModal" style="display:none;">
    <div class="mapwrap">
      <div class="maphead">
        <div class="maptitle">🧭 Instructions</div>
        <button class="mini-btn" id="helpClose" type="button">Close</button>
      </div>
      <div class="mapwrap" style="padding:12px 16px; line-height:1.5;">
        <p><b>Movement:</b> Use <kbd>WASD</kbd> or <kbd>Arrow Keys</kbd> to move your blob.</p>
        <p><b>Objective:</b> Collect <b>SEALS</b> for score, then reach the glowing <b>EXIT</b>.</p>
        <p><b>IsoSpark:</b> Pick up the cyan iso-diamond to become <b>invincible</b> for 5 seconds!</p>
        <p><b>Enemies:</b> Avoid the cleaners (red squares) one touch ends your run.</p>
        <p><b>Touch / Mobile:</b> Tap near your blob to move, or use the on-screen joystick.</p>
        <p><b>Pause:</b> Opening this screen or the map pauses the game.</p>
      </div>
    </div>
  </div>
  
  <div class="countdown" id="count"><div class="num" id="countNum">3</div></div>

  <footer class="siteFooter" id="siteFooter" aria-label="Brand">
    <a href="https://ironsignalworks.com" target="_blank" rel="noopener" aria-label="Visit Iron Signal Works">
      <img src="logo.png" alt="" />
      <span>Iron Signal Works — Cold Code, Hot Circuits.</span>
    </a>
  </footer>

  <!-- Live regions -->
  <div id="score" aria-live="polite" aria-atomic="true" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">Seals 0/0 | Score 0</div>
  <div id="status" aria-live="polite" aria-atomic="true"></div>

<script>
/* ======= MOBILE ANALOG JOYSTICK ======= */
(() => {
  const stick = document.getElementById('stick');
  if(!stick) return;
  const isCoarse = ()=> matchMedia('(hover:none) and (pointer:coarse)').matches;
  const emitKey = (code,type)=> window.dispatchEvent(new KeyboardEvent(type,{code,key:code,bubbles:true}));

  let active=false, cx=0, cy=0, dx=0, dy=0;
  const held={up:false,down:false,left:false,right:false};
  const codes={up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight'};
  const toDir=(dx,dy)=>{ const dead=8, r=Math.hypot(dx,dy); if(r<dead) return {up:0,down:0,left:0,right:0};
    const a=Math.atan2(dy,dx);
    return { left:Math.abs(Math.cos(a))>Math.abs(Math.sin(a))&&dx<0,
             right:Math.abs(Math.cos(a))>Math.abs(Math.sin(a))&&dx>0,
             up:Math.abs(Math.sin(a))>Math.abs(Math.cos(a))&&dy<0,
             down:Math.abs(Math.sin(a))>Math.abs(Math.cos(a))&&dy>0 };
  };
  const apply=d=>{ for(const k in held){ if(d[k]&&!held[k]){emitKey(codes[k],'keydown'); held[k]=true;}
                   else if(!d[k]&&held[k]){emitKey(codes[k],'keyup'); held[k]=false;} } };
  function start(e){ if(!isCoarse()) return; e.preventDefault(); active=true;
    const r=stick.getBoundingClientRect(); cx=r.left+r.width/2; cy=r.top+r.height/2;
    try{stick.setPointerCapture(e.pointerId);}catch(_){ } }
  function move(e){ if(!active) return; dx=e.clientX-cx; dy=e.clientY-cy; apply(toDir(dx,dy));
    stick.style.setProperty('--dx', Math.max(-28, Math.min(28, dx/4))+'px');
    stick.style.setProperty('--dy', Math.max(-28, Math.min(28, dy/4))+'px'); }
  function end(e){ if(!active) return; e.preventDefault(); active=false; apply({}); stick.style.setProperty('--dx','0px'); stick.style.setProperty('--dy','0px'); }
  stick.addEventListener('pointerdown', start, {passive:false});
  stick.addEventListener('pointermove',  move,  {passive:false});
  stick.addEventListener('pointerup',    end,   {passive:false});
  stick.addEventListener('pointercancel',end,   {passive:false});
  stick.addEventListener('pointerleave', end,   {passive:false});
  const style=document.createElement('style'); style.textContent=".stick::after{transform:translate(calc(-50% + var(--dx,0px)),calc(-50% + var(--dy,0px)))}"; document.head.appendChild(style);
})();
</script>

<script>
/* ======= AUDIO ENGINE ======= */
class ReakAudio{
  constructor(){
    this.ctx=null; this.enabled=true; this.gainMain=null; this.gainBgm=null;
    this.buffers=new Map(); this.loops=new Map();
    this.AUDIO_ASSETS={
      bg_loop:'audio/bg_loop.mp3',
      step:'audio/step_soft.mp3',
      pickup:'audio/pickup_seal.mp3',
      exit:'audio/exit_next.mp3',
      levelup:'audio/levelup.mp3', /* plays before transition */
      death:'audio/death_fail.mp3',
      ui_open:'audio/ui_open.mp3',
      ui_click:'audio/ui_click.mp3',
      count_tick:'audio/count_tick.mp3',
      power_isospark:'audio/power_isospark.mp3'
    };
  }
  async ensureContext(){ if(this.ctx) return; const C=window.AudioContext||window.webkitAudioContext; if(!C) return;
    this.ctx=new C(); this.gainMain=this.ctx.createGain(); this.gainMain.gain.value=0.9; this.gainMain.connect(this.ctx.destination);
    this.gainBgm=this.ctx.createGain(); this.gainBgm.gain.value=0.0; this.gainBgm.connect(this.gainMain);
    Object.entries(this.AUDIO_ASSETS).forEach(([k,u])=>this.loadBuffer(k,u).catch(()=>{}));
  }
  async resume(){ await this.ensureContext(); if(this.ctx&&this.ctx.state!=='running'){ try{await this.ctx.resume();}catch(_){}} }
  async loadBuffer(name,url){ if(!this.ctx) await this.ensureContext(); if(!this.ctx) return;
    const res=await fetch(url); const arr=await res.arrayBuffer(); const buf=await this.ctx.decodeAudioData(arr); this.buffers.set(name,buf); }
  play(name,opts={}){ if(!this.enabled) return; if(!this.ctx||this.ctx.state!=='running') return;
    const buf=this.buffers.get(name);
    if(buf){ const src=this.ctx.createBufferSource(); src.buffer=buf; if(opts.detune) try{src.detune.value=opts.detune;}catch(_){ }
      const g=this.ctx.createGain(); g.gain.value=(opts.gain??0.8); src.connect(g).connect(this.gainMain); src.start(0); return; }
  }
  startBgm(name='bg_loop',fade=0.6){ if(!this.ctx||this.ctx.state!=='running') return; this.stopBgm();
    const buf=this.buffers.get(name);
    if(buf){ const src=this.ctx.createBufferSource(); src.buffer=buf; src.loop=true; src.connect(this.gainBgm); src.start(0); this.loops.set('bgm',src); this.fade(this.gainBgm,0.0,0.6,fade); }
  }
  stopBgm(fade=0.4){ const src=this.loops.get('bgm'); if(!src) return; this.fade(this.gainBgm,this.gainBgm.gain.value,0.0,fade,()=>{ try{src.stop()}catch(_){ } this.loops.delete('bgm'); }); }
  fade(node,from,to,secs,done){ const now=this.ctx.currentTime; try{ node.gain.setValueAtTime(from,now); node.gain.linearRampToValueAtTime(to,now+secs);}catch(_){ node.gain.value=to;} if(done) setTimeout(done,secs*1000+10); }
  setMuted(m){ this.enabled=!m; if(!this.ctx) return; this.gainMain.gain.value=m?0:0.9; }
}
</script>

<script>
/* ======= GAME ======= */
(function(){
  const cvs = document.getElementById('board');
  const ctx = cvs.getContext('2d');
  const cabScreen = document.getElementById('cabScreen');
  const controlsWrap = document.getElementById('cabControls');
  const siteFooter = document.getElementById('siteFooter');
  let running = false, pendingRunReset = true;
  let paused = false;
  let transitioning = false; // freeze movement during level-up

  // Map modal
  const mapModal = document.getElementById('mapModal');
  const mapOpenBtn = document.getElementById('mapBtn');
  const mapCloseBtn = document.getElementById('mapClose');
  const mapTableBody = document.querySelector('#mapTable tbody');

  // Help modal
  const helpModal = document.getElementById('helpModal');
  const helpOpenBtn = document.getElementById('helpBtn');
  const helpCloseBtn = document.getElementById('helpClose');

  // Audio
  const audio = new ReakAudio();
  const muteBtn = document.getElementById('muteBtn');

  // Grid
  let COLS=22, ROWS=22;
  const isTouchDevice = ()=> matchMedia('(hover:none) and (pointer:coarse)').matches;
  function configureGrid(){ if(isTouchDevice()){ COLS=20; ROWS=20; } else { COLS=22; ROWS=22; } }
  configureGrid();

  // Colors
  const WALL='#172027', FLOOR='#0a0f13', RADIATION='#ff4d4d', ISOSPARK='#4be3ff';

  // RNG
  const RAND_A=1664525, RAND_C=1013904223, RAND_M=4294967296;
  const makeRng=(seed)=>{ let s=seed>>>0 || 0x1a2b3c4d; return ()=> ((s=(s*RAND_A+RAND_C)>>>0)/RAND_M); };
  const seedForLevel=(level)=>{ let x=(level|0)+0x9e3779b9; x^=x<<13; x>>>=0; x^=x>>>17; x>>>=0; x^=x<<5; x>>>=0; return x>>>0; };

  // Levels
  const RADIO_LEVELS=[{rank:1,loc:'Fission Gardens',danger:'☣️',notes:'Overgrown and humming.'},
    {rank:2,loc:'Glowworm Hall',danger:'☢️',notes:'Mild luminescence.'},
    {rank:3,loc:'Iodine Vaults',danger:'☢️',notes:'Mostly stable isotopes.'},
    {rank:4,loc:'Helium Loop Junction',danger:'☣️',notes:'Pressure failures hurt.'},
    {rank:5,loc:'Gamma Stairwell',danger:'☢️',notes:'Hot spots near lights.'},
    {rank:6,loc:'Turbine Catwalks',danger:'⚙️',notes:'Mechanical hazard.'},
    {rank:7,loc:'Moderator Shaft',danger:'☢️',notes:'Beta spikes during maintenance.'},
    {rank:8,loc:'Core Breach Gallery',danger:'☢️☢️',notes:'Cherenkov glow.'},
    {rank:9,loc:'Hot Cell Annex',danger:'☢️☢️',notes:'Cracked shields hum.'},
    {rank:10,loc:'Cobalt Gallery',danger:'☢️☢️',notes:'Gamma haze dances.'},
    {rank:11,loc:'Decay Pools',danger:'☢️☢️',notes:'Water bubbles when you whisper.'},
    {rank:12,loc:'Bunker Delta-9',danger:'☢️☢️',notes:'Old reactor materials.'},
    {rank:13,loc:'Neutron Spire',danger:'☢️☢️☢️',notes:'LF radiation pulses.'},
    {rank:14,loc:'Half-Life Bridge',danger:'☢️☢️☢️',notes:'Cross quickly.'},
    {rank:15,loc:'Coolant Cathedral',danger:'☢️☢️☢️',notes:'Geiger hymns.'},
    {rank:16,loc:'Exclusion Promenade',danger:'☢️☢️☢️',notes:'No birds.'},
    {rank:17,loc:'Control Rod Graveyard',danger:'☢️☢️☢️☢️',notes:'Spent rods.'},
    {rank:18,loc:'Sarcophagus Deep',danger:'☢️☢️☢️☢️',notes:'Unstable readings.'},
    {rank:19,loc:'Plutonium Trench',danger:'☢️☢️☢️☢️',notes:'Lethal dust.'},
    {rank:20,loc:'Annihilation Deck',danger:'☢️☢️☢️☢️☢️',notes:'Only light.'}];
  const levelNameFor=n=>`Rank ${Math.max(1,Math.min(20,n))} — ${RADIO_LEVELS[Math.max(1,Math.min(20,n))-1].loc}`;
  function renderMapModal(){ mapTableBody.innerHTML = RADIO_LEVELS.map(r=>`<tr><td class="mapcell maprank">${r.rank}</td><td class="mapcell maploc">${r.loc}</td><td class="mapcell mapdanger">${r.danger}</td><td class="mapcell mapnotes">${r.notes}</td></tr>`).join(''); }

  /* ---------- Map generation ---------- */
  let map=[], MCOLS=COLS, MROWS=ROWS, pelletsTotal=0;

  function buildRawForLevel(level){
    const rowsCount=ROWS, colsCount=COLS, rng=makeRng(seedForLevel(level));
    const grid=Array.from({length:rowsCount},()=>Array(colsCount).fill('1'));
    const stack=[[1,1]]; grid[1][1]='0';
    const dirs=[[2,0],[-2,0],[0,2],[0,-2]];
    while(stack.length){
      const [cx,cy]=stack[stack.length-1]; const nbr=[];
      for(const [dx,dy] of dirs){
        const nx=cx+dx, ny=cy+dy;
        if(ny<=0||nx<=0||ny>=rowsCount-1||nx>=colsCount-1) continue;
        if(grid[ny][nx]==='1') nbr.push([nx,ny,dx/2,dy/2]);
      }
      if(nbr.length){ const [nx,ny,wx,wy]=nbr[Math.floor(rng()*nbr.length)]; grid[cy+wy][cx+wx]='0'; grid[ny][nx]='0'; stack.push([nx,ny]); }
      else stack.pop();
    }
    const loopDensity=isTouchDevice()?0.04:0.05;
    const extra=Math.floor((rowsCount*colsCount)*loopDensity);
    for(let i=0;i<extra;i++){
      const x=1+Math.floor(rng()*(colsCount-2)), y=1+Math.floor(rng()*(rowsCount-2));
      if(grid[y][x]!=='1') continue;
      let open=(grid[y-1][x]!=='1')+(grid[y+1][x]!=='1')+(grid[y][x-1]!=='1')+(grid[y][x+1]!=='1');
      if(open>=2) grid[y][x]='0';
    }
    return grid.map(r=>r.join(''));
  }

  function buildMapFromRaw(raw){
    const cols=raw[0].length, rows=raw.length, out=new Array(rows);
    for(let y=0;y<rows;y++){
      const line=raw[y]; const row=new Array(cols);
      for(let i=0;i<cols;i++){ const ch=line[i]; row[i]=(ch==='1')?1 : 0; }
      row[0]=1; row[cols-1]=1; out[y]=row;
    }
    for(let x=0;x<out[0].length;x++){ out[0][x]=1; out[out.length-1][x]=1; }
    return {map:out, cols:out[0].length, rows:out.length};
  }

  const findPlayerSpawn=(m,cols,rows)=>{ for(let y=1;y<rows-1;y++) for(let x=1;x<cols-1;x++) if(m[y][x]===0) return {x,y}; return {x:1,y:1}; };

  function farthestReachableInterior(m, cols, rows, from, padding=1){
    const ok=(x,y)=> x>=padding && y>=padding && x<cols-padding && y<rows-padding && m[y]?.[x]!==1;
    const key=(x,y)=>x+','+y;
    const q=[[from.x,from.y,0]]; const seen=new Set([key(from.x,from.y)]);
    let far={x:from.x,y:from.y,d:0};
    while(q.length){
      const [x,y,d]=q.shift();
      if(d>far.d && ok(x,y)) far={x,y,d};
      for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx=x+dx, ny=y+dy, k=key(nx,ny);
        if(!seen.has(k) && m[ny]?.[nx]!==1){ seen.add(k); q.push([nx,ny,d+1]); }
      }
    }
    if(!ok(far.x,far.y)){
      for(let y=padding;y<rows-padding;y++) for(let x=padding;x<cols-padding;x++) if(ok(x,y)) return {x,y};
      return {x:Math.max(1,Math.min(cols-2, from.x)), y:Math.max(1,Math.min(rows-2, from.y))};
    }
    return {x:far.x,y:far.y};
  }

  function postProcessLevel(m, cols, rows, level){
    const rng = makeRng(seedForLevel(level) ^ 0xabc98388);
    const spawn = findPlayerSpawn(m, cols, rows);
    const key=(x,y)=>x+','+y;

    const q=[[spawn.x,spawn.y]]; const seen=new Set([key(spawn.x,spawn.y)]);
    const cells=[{x:spawn.x,y:spawn.y}];
    while(q.length){
      const [x,y]=q.shift();
      for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx=x+dx, ny=y+dy;
        if(m[ny]?.[nx]!==1){
          const k=key(nx,ny); if(!seen.has(k)){ seen.add(k); q.push([nx,ny]); cells.push({x:nx,y:ny}); }
        }
      }
    }

    const exit=farthestReachableInterior(m, cols, rows, spawn, 1);
    m[exit.y][exit.x]=3;

    let pelletCount=0; const pelletP=isTouchDevice()?0.50:0.58;
    for(const c of cells){
      if((c.x===spawn.x&&c.y===spawn.y) || (c.x===exit.x&&c.y===exit.y)) continue;
      if(rng()<pelletP){ m[c.y][c.x]=2; pelletCount++; }
    }
    if(pelletCount===0){
      if(m[spawn.y][spawn.x+1]===0) m[spawn.y][spawn.x+1]=2;
      else if(m[spawn.y+1]?.[spawn.x]===0) m[spawn.y+1][spawn.x]=2;
      pelletCount=1;
    }

    // IsoSparks — 1 base + 1 extra every 5 levels
    const isoCount = Math.min(1 + Math.floor(level / 5), 4);
    const options = cells.filter(c => m[c.y][c.x] === 0 && !(c.x === spawn.x && c.y === spawn.y) && !(c.x === exit.x && c.y === exit.y));
    for (let i = 0; i < isoCount && options.length; i++) {
      const pick = options.splice(Math.floor(rng() * options.length), 1)[0];
      m[pick.y][pick.x] = 4;
    }

    return {spawn, exit, pelletCount, cells};
  }

  /* ---------- Entities & timing ---------- */
  const player={x:1,y:1,pellets:0,alive:false,stepMs:100,stepAcc:0, invUntil:0};
  let hazards=[];

  const enemyStepMsForLevel = (lvl)=> {
    const base=300, min=170;
    return Math.max(min, base - (lvl-1)*7);
  };

  // UI
  const UI={ menu:document.getElementById('menu'), menuTitle:document.getElementById('menuTitle'),
    menuSub:document.getElementById('menuSub'), play:document.getElementById('play'),
    score:document.getElementById('score'), levelName:document.getElementById('levelName'),
    veil:document.getElementById('veil'), countWrap:document.getElementById('count'), countNum:document.getElementById('countNum') };
  const DEFAULT_MENU_SUB=UI.menuSub.innerHTML;

  // ---------- Modal controls + pause handling ----------
  const openHelp = () => { paused = true; UI.veil.style.display = 'block'; helpModal.style.display = 'block'; };
  const closeHelp = () => { helpModal.style.display = 'none'; if (UI.menu.style.display !== 'block' && mapModal.style.display !== 'block') UI.veil.style.display = 'none'; paused = false; };
  helpOpenBtn.addEventListener('click', async (e) => { e.preventDefault(); await audio.resume(); openHelp(); });
  helpCloseBtn.addEventListener('click', (e) => { e.preventDefault(); closeHelp(); });

  const openMap = () => { paused = true; renderMapModal(); UI.veil.style.display = 'block'; mapModal.style.display = 'block'; };
  const closeMap = () => { mapModal.style.display = 'none'; if (UI.menu.style.display !== 'block' && helpModal.style.display !== 'block') UI.veil.style.display = 'none'; paused = false; };
  mapOpenBtn.addEventListener('click', async (e) => { e.preventDefault(); await audio.resume(); openMap(); });
  mapCloseBtn.addEventListener('click', (e) => { e.preventDefault(); closeMap(); });
  UI.veil?.addEventListener('click', () => {
    if (mapModal.style.display === 'block' && UI.menu.style.display !== 'block') closeMap();
    if (helpModal.style.display === 'block' && UI.menu.style.display !== 'block') closeHelp();
  });

  // Input
  const keys=new Set();
  window.addEventListener('keydown', async (e)=>{
    if (paused || transitioning) return; // ignore during pause/transition
    keys.add(e.code);
    if(!running && (e.code.startsWith('Arrow')||e.code.startsWith('Key')||e.code==='Enter'||e.code==='Space')){
      await audio.resume(); startWithCountdown();
    }
  }, {passive:false});
  window.addEventListener('keyup', e=> keys.delete(e.code), {passive:true});

  // Buttons
  let muted=false;
  muteBtn.addEventListener('click', async ()=>{ await audio.resume(); muted=!muted; audio.setMuted(muted); muteBtn.textContent=muted?'🔇':'🔊'; });

  // Start / levels
  let level=1, score=0;
  function startLevel(n){
    configureGrid(); level=n; transitioning=false;

    const raw=buildRawForLevel(level);
    const built=buildMapFromRaw(raw);
    map=built.map; MCOLS=built.cols; MROWS=built.rows;
    const {spawn, exit, pelletCount, cells} = postProcessLevel(map, MCOLS, MROWS, level);
    pelletsTotal = pelletCount;

    player.x=spawn.x; player.y=spawn.y;
    player.pellets=0; player.stepMs=100; player.stepAcc=0; player.invUntil=0; player.alive=true;

    // ---- SAFE ENEMY SPAWN: reachable floor tiles, far from player & not on exit
    const dist=(a,b)=> Math.abs(a.x-b.x)+Math.abs(a.y-b.y);
    const floorCells = cells.filter(c => map[c.y][c.x]===0 && !(c.x===player.x&&c.y===player.y) && !(c.x===exit.x&&c.y===exit.y));
    floorCells.sort((a,b)=> dist(b, player) - dist(a, player)); // farthest first
    const enemiesCount = Math.min(1 + Math.floor((level - 1) / 4), 6);
    hazards = [];
    const stepMs = enemyStepMsForLevel(level);
    for (let i=0; i<enemiesCount; i++){
      const pick = floorCells[Math.min(i*3, Math.max(0, floorCells.length-1))] || floorCells[floorCells.length-1];
      hazards.push({ x: pick.x, y: pick.y, acc: 0, stepMs });
    }

    UI.levelName.textContent=levelNameFor(level);
    running=true; UI.veil.style.display='none'; UI.menu.style.display='none'; mapModal.style.display='none'; siteFooter.style.display='none';
    audio.startBgm('bg_loop',0.6);
    updateHUD(); sizeCanvasToViewport();
    lastTime=performance.now(); requestAnimationFrame(loop);
  }

  async function startWithCountdown(){
    if(pendingRunReset){ score=0; level=1; pendingRunReset=false; }
    UI.menu.style.display='none'; UI.veil.style.display='none';
    await audio.resume();
    let n=3; UI.countNum.textContent=n; UI.countWrap.style.display='flex';
    const tick=()=> audio.play('count_tick',{gain:0.45});
    const step=()=>{ tick(); if(n<=1){ UI.countWrap.style.display='none'; startLevel(level); return; } n--; UI.countNum.textContent=n; setTimeout(step,420); };
    setTimeout(step,520);
  }
  UI.play.addEventListener('click', async e=>{ e.preventDefault(); await audio.resume(); if(!running) startWithCountdown(); });

  function updateHUD(){ UI.score.textContent=`Seals: ${player.pellets}/${pelletsTotal} | Score: ${score} | L${level}`; }

  const isWall=(x,y)=> map[y]?.[x]===1, isExit=(x,y)=> map[y]?.[x]===3;

  /* ---------- Time-based step ---------- */
  function handlePlayerStep(){
    if (transitioning) return; // freeze movement on exit
    let dx=0, dy=0; if(keys.has('ArrowUp')||keys.has('KeyW')) dy=-1; else if(keys.has('ArrowDown')||keys.has('KeyS')) dy=1;
    else if(keys.has('ArrowLeft')||keys.has('KeyA')) dx=-1; else if(keys.has('ArrowRight')||keys.has('KeyD')) dx=1;
    if(dx||dy){
      const nx=player.x+dx, ny=player.y+dy; if(!isWall(nx,ny)){
        player.x=nx; player.y=ny; audio.play('step',{gain:0.18});

        const cell=map[ny][nx];
        if(cell===2){ map[ny][nx]=0; player.pellets++; score+=10; audio.play('pickup',{gain:0.35}); }
        else if(cell===4){ map[ny][nx]=0; audio.play('power_isospark',{gain:0.45}); player.invUntil = performance.now()+5000; }

        if(isExit(nx,ny) && !transitioning){
          // LEVEL-UP: sound first, immediate freeze, then transition
          transitioning = true;
          keys.clear?.(); // stop held keys if Set supports clear; fallback below
          // fallback: remove common keys
          ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD','Space','Enter'].forEach(k=>keys.delete(k));
          score += 100;
          audio.play('levelup',{gain:0.6});
          const next = level + 1;
          if(next>20){ showVictory(); return; }
          setTimeout(()=>{ startLevel(next); }, 520);
        }
      }
    }
  }

  function handleHazardsStep(){
    if (transitioning) return; // freeze enemies during level-up
    for(const h of hazards){
      // BFS to player (bounded). If unreachable, do greedy step toward player.
      const key=(x,y)=>x+","+y;
      const q=[[h.x,h.y]], prev=new Map(); prev.set(key(h.x,h.y),null);
      let found=false;
      while(q.length){
        const [x,y]=q.shift(); if(x===player.x&&y===player.y){ found=true; break; }
        for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=x+dx, ny=y+dy, cell=map[ny]?.[nx];
          if(cell!==1 && !prev.has(key(nx,ny))){ prev.set(key(nx,ny),[x,y]); q.push([nx,ny]); }
        }
      }
      if(found){
        let cur=[player.x,player.y];
        while(prev.get(key(cur[0],cur[1])) && !(prev.get(key(cur[0],cur[1]))[0]===h.x && prev.get(key(cur[0],cur[1]))[1]===h.y)) cur=prev.get(key(cur[0],cur[1]));
        if(cur){ h.x=cur[0]; h.y=cur[1]; }
      }else{
        // Greedy fallback: step to any neighbor that reduces Manhattan distance & isn't a wall
        const cand=[[1,0],[-1,0],[0,1],[0,-1]].map(([dx,dy])=>({x:h.x+dx,y:h.y+dy}));
        let best={x:h.x,y:h.y, d:999};
        const dm=(x,y)=> Math.abs(x-player.x)+Math.abs(y-player.y);
        for(const c of cand){
          if(map[c.y]?.[c.x]!==1){ const d=dm(c.x,c.y); if(d<best.d){ best={x:c.x,y:c.y,d}; } }
        }
        if(best.d<999){ h.x=best.x; h.y=best.y; }
      }
    }
  }

  function tryCollide(){
    if(performance.now()<player.invUntil) return false;
    for(const h of hazards){ if(h.x===player.x&&h.y===player.y){ death(); return true; } }
    return false;
  }

  function death(){ running=false; audio.play('death',{gain:0.45}); audio.stopBgm(0.4);
    pendingRunReset=true;
    const sub=`Seals ${player.pellets}/${pelletsTotal} | Score ${score} | ${levelNameFor(level)}`;
    showOverlay('GAME OVER', sub, 'Restart'); siteFooter.style.display='block';
  }
  function showVictory(){ running=false; audio.stopBgm(0.4); pendingRunReset=true;
    const sub=`All 20 ranks cleared. Run score ${score}`;
    showOverlay('CONTAINMENT SECURED', sub, 'Restart'); siteFooter.style.display='block';
  }
  function showOverlay(title,subtitle,cta){ UI.menu.querySelector('.title').textContent=title; UI.menu.querySelector('.subtitle').innerHTML=subtitle; UI.play.textContent=cta; UI.veil.style.display='block'; UI.menu.style.display='block'; }

  /* ---------- Render ---------- */
  let drawTick=0;
  function draw(){
    const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1));
    const cssW=cvs.clientWidth|0, cssH=cvs.clientHeight|0;
    if(cvs.width!==cssW*dpr || cvs.height!==cssH*dpr){ cvs.width=cssW*dpr; cvs.height=cssH*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); }
    drawTick++;
    ctx.fillStyle=FLOOR; ctx.fillRect(0,0,cssW,cssH);
    const cell=Math.floor(Math.min(cssW,cssH)/COLS);
    const offX=Math.floor((cssW-cell*COLS)/2), offY=Math.floor((cssH-cell*ROWS)/2);

    for(let y=0;y<MROWS;y++){
      for(let x=0;x<MCOLS;x++){
        const c=map[y][x], px=offX+x*cell, py=offY+y*cell;
        if(c===1){ ctx.fillStyle='#0f161b'; ctx.fillRect(px,py,cell,cell); ctx.fillStyle='rgba(61,255,122,.05)'; ctx.fillRect(px+2,py+2,cell-4,cell-4); }
        else if(c===2){ ctx.fillStyle='#9ee6b7'; const s=Math.max(3,Math.floor(cell*0.25)); const pad=(cell-s)>>1; ctx.fillRect(px+pad,py+pad,s,s); }
        else if(c===3){ const a=0.6+0.35*Math.sin(drawTick*0.1); ctx.fillStyle=`rgba(255,211,77,${a})`; const s=Math.max(6,Math.floor(cell*0.6)); const pad=(cell-s)>>1; ctx.fillRect(px+pad,py+pad,s,s); }
        else if(c===4){ // IsoSpark diamond
          const s=Math.max(6,Math.floor(cell*0.45)); const pad=(cell-s)>>1;
          ctx.fillStyle=ISOSPARK; ctx.beginPath();
          ctx.moveTo(px+pad+s/2, py+pad);
          ctx.lineTo(px+pad+s,   py+pad+s/2);
          ctx.lineTo(px+pad+s/2, py+pad+s);
          ctx.lineTo(px+pad,     py+pad+s/2);
          ctx.closePath(); ctx.fill();
        }
      }
    }

    // Player + neon pump when invincible
    const ppx=offX+player.x*cell, ppy=offY+player.y*cell;
    const inv = performance.now()<player.invUntil;
    if(inv){
      const t = performance.now()*0.006;
      const grow = 0.12 + 0.06*(0.5+0.5*Math.sin(t));
      const expand = Math.floor(cell*grow);

      // Outer additive glow
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowBlur = Math.max(10, cell*0.9);
      ctx.shadowColor = 'rgba(75,227,255,0.9)';
      ctx.fillStyle = 'rgba(75,227,255,0.35)';
      ctx.fillRect(ppx+Math.floor(cell*0.10)-expand/2, ppy+Math.floor(cell*0.10)-expand/2, Math.floor(cell*0.80)+expand, Math.floor(cell*0.80)+expand);
      ctx.restore();

      // Soft breathing inner glow
      ctx.save();
      ctx.globalAlpha = 0.25 + 0.25*(0.5+0.5*Math.sin(t*1.3));
      ctx.fillStyle = 'rgba(75,227,255,0.9)';
      ctx.fillRect(ppx+Math.floor(cell*0.14), ppy+Math.floor(cell*0.14), Math.floor(cell*0.72), Math.floor(cell*0.72));
      ctx.restore();
    }

    // Base blob
    ctx.fillStyle=inv?ISOSPARK:'#3dff7a';
    ctx.fillRect(ppx+Math.floor(cell*0.18), ppy+Math.floor(cell*0.18), Math.floor(cell*0.64), Math.floor(cell*0.64));

    // Hazards
    for(const h of hazards){
      const gx=offX+h.x*cell, gy=offY+h.y*cell;
      ctx.fillStyle=RADIATION; ctx.fillRect(gx+Math.floor(cell*0.12), gy+Math.floor(cell*0.12), Math.floor(cell*0.76), Math.floor(cell*0.76));
      ctx.fillStyle='#111'; const eye=Math.max(2,Math.floor(cell*0.16));
      ctx.fillRect(gx+Math.floor(cell*0.28), gy+Math.floor(cell*0.34), eye, eye);
      ctx.fillRect(gx+Math.floor(cell*0.64), gy+Math.floor(cell*0.34), eye, eye);
    }

    // Toggle cabinet glow class once per frame
    cvs.classList.toggle('glow', inv);

    }

  let lastTime=performance.now();
  function loop(now){
    if(!running) return;
    if (paused) { draw(); requestAnimationFrame(loop); return; }
    const dt = Math.min(100, now - lastTime);
    lastTime = now;

    // Only update logic if not transitioning
    if(!transitioning){
      player.stepAcc += dt;
      if(player.stepAcc >= player.stepMs){ player.stepAcc -= player.stepMs; handlePlayerStep(); }

      for(const h of hazards){
        h.acc = (h.acc||0) + dt;
        if(h.acc >= h.stepMs){ h.acc -= h.stepMs; handleHazardsStep(); }
      }
      if(tryCollide()) return;
    }

    updateHUD(); draw(); requestAnimationFrame(loop);
  }

  // Fit canvas (accounts for fixed header)
  function sizeCanvasToViewport(){
    const topH = document.querySelector('.header-spacer').getBoundingClientRect().height;
    const ctrlH = (getComputedStyle(controlsWrap).display==='none') ? 0 : controlsWrap.getBoundingClientRect().height + 10;
    const vh = window.innerHeight;
    const vw = window.innerWidth;
    const availH = Math.max(240, vh - topH - ctrlH - 6);
    const size = Math.floor(Math.min(vw - 16, availH));
    cvs.style.maxWidth = size+'px';
    cvs.style.maxHeight = size+'px';
    cabScreen.style.placeItems = 'center';
  }
  window.addEventListener('resize', sizeCanvasToViewport, {passive:true});
  window.addEventListener('orientationchange', sizeCanvasToViewport, {passive:true});
  requestAnimationFrame(sizeCanvasToViewport);

  // Tap controls
  (function setupTapMove(){
    const pressOnce=(code)=>{ keys.add(code); try{ navigator.vibrate&&navigator.vibrate(6); }catch(_){ } setTimeout(()=> keys.delete(code), 60); };
    const handleTap=(clientX,clientY)=>{
      if (transitioning) return;
      const cssW=cvs.clientWidth|0, cssH=cvs.clientHeight|0;
      const cell=Math.floor(Math.min(cssW,cssH)/COLS);
      const offX=Math.floor((cssW-cell*COLS)/2), offY=Math.floor((cssH-cell*ROWS)/2);
      const rect=cvs.getBoundingClientRect();
      const x=clientX-rect.left, y=clientY-rect.top;
      const ppx=offX+(player.x+.5)*cell, ppy=offY+(player.y+.5)*cell;
      const dx=x-ppx, dy=y-ppy;
      if(Math.abs(dx)>Math.abs(dy)) pressOnce(dx>0?'ArrowRight':'ArrowLeft'); else pressOnce(dy>0?'ArrowDown':'ArrowUp');
    };
    cvs.addEventListener('pointerup', async e=>{ if(e.pointerType==='mouse'||e.pointerType==='touch'){ await audio.resume(); handleTap(e.clientX,e.clientY); e.preventDefault(); } }, {passive:false});
    cvs.addEventListener('pointerdown', async e=>{ if(!running){ await audio.resume(); startWithCountdown(); } }, {passive:true});
  })();

  // Initial overlay
  (function showStart(){ document.getElementById('menuTitle').textContent='REAKTOR 404'; UI.veil.style.display='block'; UI.menu.style.display='block'; UI.menu.querySelector('.subtitle').innerHTML=DEFAULT_MENU_SUB; })();
})();
</script>
</body>
</html>
