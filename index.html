<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>REAKTOR 404 - Cleaners Run</title>
  <meta name="description" content="Top-down pixel maze console." />
  <meta name="theme-color" content="#0b0b0b" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Doto:wght@400..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Sixtyfour+Convergence:SCAN@-45..45&display=swap" rel="stylesheet">

  <style>
:root {
  --bg:#050607;
  --ink:#e9f0f1;
  --accent:#3dff7a;
  --haz:#ffcc00;
  --danger:#ff4d4d;
  --wall:#0e1216;
  --layout-pad:clamp(12px,3vw,28px);
  --gap:10px;
  --ui-scale:.92;
  --console-max:480px;
  --board-max:760px;
  --bevel-radius:14px;
  --bevel-top:rgba(255,255,255,.12);
  --bevel-bottom:rgba(0,0,0,.55);
  --panel-bg-1:rgba(20,26,30,.9);
  --panel-bg-2:rgba(10,14,18,.92);
  --panel-glow:rgba(0,0,0,.35);
  --safe-b: env(safe-area-inset-bottom, 0px);
}
html,body { height: 100%; overflow-x:hidden }
body{
  margin: 0;
  min-height: 100dvh;
  background: var(--bg);
  color: var(--ink);
  font-family: "Doto",system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
  display: flex;
  justify-content: center;
  padding: var(--layout-pad);
  box-sizing: border-box;
  -webkit-user-select: none;
  user-select: none;
  touch-action: none; /* re-enable where needed */
  overflow:auto;
  text-align:center;
}
@media(hover:hover) and (pointer:fine){ body{ overflow:hidden } }

.wrap{
  position: relative;
  width: 100%;
  max-width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap:var(--gap);
}

.console{
  width: min(86vw,var(--console-max));
  max-width: 100%;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: var(--gap);
  transform: scale(var(--ui-scale));
  transform-origin: top center;
  will-change: transform;
  margin-inline: auto;
  margin-top:-20px;
}

.bevel{
  border: none;
  border-radius: var(--bevel-radius);
  background: linear-gradient(145deg,var(--panel-bg-1),var(--panel-bg-2));
  box-shadow:inset 2px 2px 0 var(--bevel-top),inset -2px -2px 0 var(--bevel-bottom),0 6px 16px var(--panel-glow);
}

.console-head,.console-foot{
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px 12px;
  min-height: 44px;
  text-align:center;
}

.titlebar{
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  flex-wrap: wrap;
  width: 100%;
  font-weight: 800;
  letter-spacing: .08em;
  text-transform: uppercase;
  font-size: 14px;
  opacity:.95;
}
.titlebar .right{
  margin-left:auto;
  display:flex; gap:6px; align-items:center;
}
.iconbtn{
  pointer-events:auto;
  -webkit-appearance:none; appearance:none; border:0; background:0; color:var(--ink);
  width:36px; height:36px; border-radius:10px;
  display:grid; place-items:center; cursor:pointer;
  box-shadow: inset 2px 2px 0 var(--bevel-top), inset -2px -2px 0 var(--bevel-bottom), 0 6px 14px rgba(0,0,0,.35);
  background: linear-gradient(145deg,rgba(255,255,255,.08),rgba(0,0,0,.35));
}
.iconbtn:active{ transform:translateY(1px) }

.levelname{
  font-weight: 800;
  font-size: 14px;
  letter-spacing: .06em;
  text-transform: uppercase;
  opacity: .9;
  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
  hyphens: auto;
}

.scoreline{
  font-weight: 800;
  font-size:16px;
}

.frame{
  position: relative;
  padding:10px;
}
.frame::before{
  content: "";
  position: absolute;
  inset: 0;
  border-radius: calc(var(--bevel-radius) + 6px);
  pointer-events: none;
  background: linear-gradient(180deg,rgba(255,255,255,.06),rgba(0,0,0,0));
  mix-blend-mode:soft-light;
}

canvas{
  display: block;
  width: 100%;
  height: auto;
  aspect-ratio: 1/1;
  image-rendering: pixelated;
  border-radius: 16px;
  background: #050607;
  box-shadow: inset 0 0 0 2px rgba(255,255,255,.06);
  z-index: 1;
  max-width: var(--board-max);
  margin-inline:auto;
  touch-action: none; /* canvas captures gestures */
}

/* ===== Mobile joystick ===== */
.joystick-wrap{
  display:none;
  align-self:center;
  margin-top: 6px;
  padding-bottom: calc(8px + var(--safe-b));
}
@media(hover:none) and (pointer:coarse){
  .joystick-wrap{ display:block }
  :root { --console-max:100vw; --board-max:100vh }
}
.joystick{
  position:relative;
  width:min(56vw,240px);
  aspect-ratio:1/1;
  border-radius:50%;
  background: radial-gradient(120px 120px at 50% 50%, rgba(255,255,255,.06), rgba(0,0,0,.35));
  box-shadow: inset 2px 2px 0 var(--bevel-top), inset -2px -2px 0 var(--bevel-bottom), 0 6px 14px rgba(0,0,0,.35);
  touch-action:none;
}
.j-base{
  position:absolute; inset:10%; border-radius:50%;
  border:1px dashed rgba(255,255,255,.18);
}
.j-knob{
  position:absolute;
  left:50%; top:50%;
  width:34%; aspect-ratio:1/1; border-radius:50%;
  transform:translate(-50%,-50%);
  background: linear-gradient(145deg,rgba(255,255,255,.10),rgba(0,0,0,.55));
  box-shadow: inset 2px 2px 0 var(--bevel-top), inset -2px -2px 0 var(--bevel-bottom), 0 6px 14px rgba(0,0,0,.35);
}

/* Overlays & map/table (unchanged, with minor tweaks for mobile) */
.veil{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.65);
  display: none;
  backdrop-filter: saturate(.8) blur(2px);
  z-index:98;
}

.cta{
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%) scale(var(--ui-scale));
  transform-origin: center;
  text-align: center;
  font-family: "Doto",system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
  z-index: 99;
  width: min(92%,560px);
  max-width: 100vw;
  box-sizing: border-box;
  padding-left: 8px;
  padding-right:8px;
}
.cta .title{
  font-family: "Sixtyfour Convergence",system-ui;
  font-weight: 800;
  font-size: clamp(16px,7.5vw,60px);
  line-height: 1.05;
  letter-spacing: .03em;
  text-transform: uppercase;
  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
  hyphens:auto;
}
.cta .subtitle{
  opacity: .95;
  margin-top:10px;
  font-size: clamp(12px, 3.6vw, 16px);
  line-height: 1.35;
}
.cta.cta--gameover .title{ color: var(--danger); font-size: clamp(16px, 6vw, 44px) }
.cta.cta--victory .title{ color: var(--haz);    font-size: clamp(16px, 4.2vw, 30.8px) }

.cta.cta--map{
  width: min(92%,720px);
  max-height: 80vh;
  overflow: auto;
  text-align: left;
  padding: 0 8px;
  background: #000;
  border:1px solid rgba(255,255,255,.1);
  touch-action: auto;
}
  .cta.cta--victory .title,
  .cta.cta--gameover .title{
    font-size: clamp(18px, 4.6vw, 34px);
    line-height: 1.05;
    letter-spacing: .06em;
  }
  .cta.cta--victory .subtitle,
  .cta.cta--gameover .subtitle{
    font-size: clamp(12px, 2.8vw, 14px);
    line-height: 1.25;
    opacity: .92;
    word-break: break-word;
    overflow-wrap: anywhere;
  }
  @media (max-width: 600px){
    .cta.cta--victory,
    .cta.cta--gameover{
      width: min(88vw, 380px);
      gap: 12px;
      padding: clamp(18px, 7vw, 28px);
    }
  }

.cta.cta--menu{
  padding: clamp(28px, 8vw, 56px);
  gap: clamp(14px, 3.2vw, 24px);
}
.cta.cta--menu .title{ margin:2px 0 clamp(6px, 2.2vw, 12px) 0 }
.cta.cta--menu .subtitle{
  margin: 0 0 clamp(12px, 3vw, 18px) 0;
  font-size: clamp(13px, 3.8vw, 17px);
  line-height: 1.35;
}
.cta.cta--menu .btn-row{ gap: clamp(10px, 2.6vw, 16px) }
@media (max-width: 600px){
  .cta.cta--menu{ width: min(92vw, 480px); padding: clamp(24px, 9vw, 44px) }
  .cta.cta--menu .btn-row .btn{ width: 100% }
}

.mapwrap{ padding: 16px 0 6px; background:#000 }
.maphead{
  display: flex; align-items: center; justify-content: space-between; gap: 12px;
  position: sticky; top: 0; background: #000; padding: 10px 6px 8px;
  border-bottom: 1px solid rgba(255,255,255,.16); z-index:1
}
.maptitle{
  font-family: "Sixtyfour Convergence",system-ui;
  font-weight: 800; font-size: 18px; letter-spacing: .06em; text-transform:uppercase
}
.maptable{
  width: 100%; border-collapse: collapse; font-size: 14px; background: #000; table-layout:fixed
}
.maptable th{
  text-align: left; font-weight: 900; letter-spacing: .06em; text-transform: uppercase;
  opacity: .85; padding: 10px 12px; font-size: 12px; border-bottom:1px solid rgba(255,255,255,.16)
}
.maptable tr{ background:#000 }
.maptable tr:hover{ background:#0b0b0b }
.mapcell{
  padding: 10px 12px; vertical-align: top; border-bottom: 1px solid rgba(255,255,255,.08);
  overflow-wrap: anywhere; word-break:break-word
}
.maprank{ width: 3.5ch; font-weight: 900; text-align:center }
.maploc{ font-weight:800 }
.mapdanger{ width:7ch }
.mapnotes{ opacity:.92 }
@media(max-width:800px){
  .maptitle{ font-size: 16px; letter-spacing:.05em }
}

.countdown{
  position: fixed; left: 0; right: 0; top: 0; bottom: 0;
  display: none; align-items: center; justify-content: center;
  pointer-events: none; z-index: 100;
  transform: scale(var(--ui-scale)); transform-origin:center
}
.countdown .num{
  font: 900 64px/1 "Doto",system-ui;
  letter-spacing: .06em;
  text-shadow:0 0 18px rgba(255,211,77,.45)
}

/* Buttons */
button,.btn,.closebtn{
  font-family: inherit;
  -webkit-appearance: none;
  appearance: none;
  border: 0; background: 0; color:inherit;
}
.btn,.closebtn{
  display: inline-block; box-sizing: border-box; cursor: pointer;
  padding: 12px 18px;
  min-height: 44px;
  border-radius: 12px; line-height: 1.1; font-size: 18px; font-weight: 800;
  letter-spacing: .06em; text-transform: uppercase; text-decoration: none; color: var(--ink);
  background: linear-gradient(145deg,rgba(255,255,255,.08),rgba(0,0,0,.35));
  box-shadow: inset 2px 2px 0 var(--bevel-top),inset -2px -2px 0 var(--bevel-bottom),0 6px 14px rgba(0,0,0,.35);
  transition:transform .06s ease,filter .2s ease
}
.btn:hover,.closebtn:hover{ filter:brightness(1.08) }
.btn:active,.closebtn:active{ transform:translateY(1px) }
.btn:focus-visible,.closebtn:focus-visible{ outline: 2px solid var(--accent); outline-offset:3px }
.maphead .closebtn{ margin-top:0 }
.btn-row{ display: flex; gap: 10px; justify-content: center; flex-wrap:wrap }
.btn-row .btn{ margin-top:0 }

.crt::after{
  content: ""; position: fixed; inset: 0; pointer-events: none;
  mix-blend-mode: overlay; opacity: .22;
  background:repeating-linear-gradient(to bottom,rgba(255,255,255,.06) 0,rgba(255,255,255,.06) 1px,rgba(0,0,0,0) 2px,rgba(0,0,0,0) 4px)
}
#status{ display:none!important }
@media(max-width:600px){
  .wrap{ gap:8px }
  .crt::after{ display:none }
  .cta:not(.cta--map){
    width:min(88vw,420px);
    max-width:100%;
    max-height:min(92vh,560px);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:16px;
    padding:clamp(20px,8vw,36px);
    box-sizing:border-box;
    overflow:auto;
  }
  .cta:not(.cta--map) .title{
    order:1;
    width:100%;
    font-size:clamp(24px,8vw,56px);
    line-height:1.05;
    letter-spacing:.025em;
    flex-grow:1;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    white-space:normal;
    word-break: break-word;
    overflow-wrap:anywhere;
    hyphens:auto;
  }
  .cta:not(.cta--map) .subtitle{ order:2 }
  .cta:not(.cta--map) .btn-row{
    order:3;
    width:100%;
    flex-direction:column;
    gap:12px;
  }
  .cta:not(.cta--map) .btn-row .btn{
    width:100%;
  }
}

/* ===== Site footer (hidden by default; only shown on victory/gameover) ===== */
.siteFooter{
  position: fixed;
  left: 50%;
  bottom: max(10px, calc(8px + env(safe-area-inset-bottom, 0px)));
  transform: translateX(-50%);
  z-index: 100; /* above veil(98) and overlays (99) */
  pointer-events: auto;
  display: none; /* <-- default hidden */
}
.siteFooter a{
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  border-radius: 999px;
  text-decoration: none;
  color: var(--ink);
  font-weight: 800;
  letter-spacing: .02em;
  background: linear-gradient(145deg, rgba(255,255,255,.06), rgba(0,0,0,.35));
  box-shadow: inset 2px 2px 0 var(--bevel-top), inset -2px -2px 0 var(--bevel-bottom), 0 6px 14px rgba(0,0,0,.35);
  backdrop-filter: blur(4px) saturate(1.1);
  -webkit-tap-highlight-color: transparent;
  touch-action: auto;
}
.siteFooter a:hover{ filter: brightness(1.08); }
.siteFooter img{
  width: 20px; height: 20px; object-fit: contain; display:block;
}
.siteFooter span{
  font-size: 12px;
  white-space: nowrap;
}
@media (max-width: 420px){
  .siteFooter span{ display:none; }
  .siteFooter a{ padding: 9px 10px; }
}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="console">
      <div class="console-head bevel">
        <div class="titlebar" style="pointer-events:auto">
          <span class="levelname" id="levelName">Rank 1 — Fission Gardens</span>
          <div class="right">
            <button class="iconbtn" id="muteBtn" aria-label="Toggle sound" title="Mute/Unmute">🔊</button>
            <button class="iconbtn" id="mapBtn" type="button" aria-label="Map">🗺️</button>
          </div>
        </div>
      </div>

      <div class="frame bevel" id="board">
        <canvas id="game" width="512" height="512" aria-label="REAKTOR 404"></canvas>
      </div>

      <!-- Mobile joystick -->
      <div class="joystick-wrap" id="joyWrap" aria-hidden="true">
        <div class="joystick" id="joystick">
          <div class="j-base"></div>
          <div class="j-knob" id="joyKnob"></div>
        </div>
      </div>

      <div class="console-foot bevel">
        <div class="scoreline" id="score">Seals: 0/0 &nbsp;|&nbsp; Score: 0 &nbsp;|&nbsp; L1</div>
        <span class="info" id="status">hidden</span>
      </div>
    </div>
  </div>

  <!-- GLOBAL OVERLAYS -->
  <div class="veil" id="veil"></div>

  <!-- Main menu -->
  <div class="cta cta--menu" id="menu">
    <div class="title" id="menuTitle">REAKTOR 404</div>
    <div class="subtitle" id="menuSub">You are a sentient radioactive blob sent by grocery clerks to collect the bill. Collect <b>SEALS</b> for bonus points, or bolt for the exit. Avoid the Cleaners.</div>
    <div class="btn-row">
      <a class="btn" href="#" id="play">Start</a>
    </div>
  </div>

  <!-- Map modal -->
  <div class="cta cta--map" id="mapModal" style="display:none;">
    <div class="mapwrap">
      <div class="maphead">
        <div class="maptitle">☢️ Radioactive Danger</div>
        <button class="closebtn" id="mapClose" type="button">Close</button>
      </div>
      <table class="maptable" id="mapTable">
        <thead>
          <tr>
            <th>Rank</th>
            <th>Location</th>
            <th>Danger</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody><!-- injected by JS --></tbody>
      </table>
    </div>
  </div>

  <!-- Countdown -->
  <div class="countdown" id="count"><div class="num" id="countNum">3</div></div>

  <!-- Footer (outside the console container; hidden by default—shown only on victory/gameover) -->
  <footer class="siteFooter" id="siteFooter" aria-label="Brand">
    <a href="https://ironsignalworks.com" target="_blank" rel="noopener"
       aria-label="Visit Iron Signal Works">
      <img src="logo.png" alt="" />
      <span>Iron Signal Works — Cold Code, Hot Circuits.</span>
    </a>
  </footer>

<script>
/* ======= AUDIO ENGINE (WebAudio with safe fallbacks) ======= */
class ReakAudio{
  constructor(){
    this.ctx = null;
    this.enabled = true;
    this.gainMain = null;
    this.gainBgm = null;
    this.buffers = new Map();
    this.loops = new Map();
    this.startedOnce = false;

    // Replace these with your actual files later:
    this.AUDIO_ASSETS = {
      bg_loop: 'audio/bg_loop.mp3',
      step: 'audio/step_soft.mp3',
      pickup: 'audio/pickup_seal.mp3',
      exit: 'audio/exit_next.mp3',
      death: 'audio/death_fail.mp3',
      ui_open: 'audio/ui_open.mp3',
      ui_click: 'audio/ui_click.mp3',
      count_tick: 'audio/count_tick.mp3'
    };
  }
  async ensureContext(){
    if(this.ctx) return;
    const C = window.AudioContext || window.webkitAudioContext;
    if(!C) return;
    this.ctx = new C();
    this.gainMain = this.ctx.createGain();
    this.gainMain.gain.value = 0.9;
    this.gainMain.connect(this.ctx.destination);

    this.gainBgm = this.ctx.createGain();
    this.gainBgm.gain.value = 0.0;
    this.gainBgm.connect(this.gainMain);

    Object.entries(this.AUDIO_ASSETS).forEach(([name, url])=>{
      this.loadBuffer(name,url).catch(()=>{});
    });
  }
  async resume(){
    await this.ensureContext();
    if(this.ctx && this.ctx.state !== 'running'){
      try{ await this.ctx.resume(); }catch(_){}
    }
    this.startedOnce = true;
  }
  async loadBuffer(name,url){
    if(!this.ctx) await this.ensureContext();
    if(!this.ctx) return;
    const res = await fetch(url);
    const arr = await res.arrayBuffer();
    const buf = await this.ctx.decodeAudioData(arr);
    this.buffers.set(name, buf);
  }
  play(name,opts={}){
    if(!this.enabled) return;
    if(!this.ctx){ this.ensureContext(); return; }
    if(this.ctx.state!=='running') return;
    const buf=this.buffers.get(name);
    if(buf){
      const src=this.ctx.createBufferSource();
      src.buffer=buf;
      if(opts.detune) try{ src.detune.value=opts.detune; }catch(_){}
      const g=this.ctx.createGain();
      g.gain.value=(opts.gain??0.8);
      src.connect(g).connect(this.gainMain);
      src.start(0);
      return;
    }
    this.beep(opts.freq??600, opts.len??0.06, opts.gain??0.06);
  }
  beep(freq=600, dur=0.06, gain=0.06){
    if(!this.enabled) return;
    if(!this.ctx || this.ctx.state!=='running') return;
    const o=this.ctx.createOscillator();
    const g=this.ctx.createGain();
    o.frequency.value=freq; o.type='square';
    g.gain.value=gain;
    o.connect(g).connect(this.gainMain);
    o.start(); o.stop(this.ctx.currentTime+dur);
  }
  startBgm(name='bg_loop', fade=0.6){
    if(!this.enabled || !this.ctx || this.ctx.state!=='running') return;
    this.stopBgm();
    const buf=this.buffers.get(name);
    if(buf){
      const src=this.ctx.createBufferSource();
      src.buffer=buf; src.loop=true; src.connect(this.gainBgm); src.start(0);
      this.loops.set('bgm',src);
      this.fadeGain(this.gainBgm,0.0,0.6,fade);
    }else{
      const o=this.ctx.createOscillator(); o.type='triangle'; o.frequency.value=180;
      o.connect(this.gainBgm); o.start(); this.loops.set('bgm',o);
      this.fadeGain(this.gainBgm,0.0,0.15,0.6);
    }
  }
  stopBgm(fade=0.4){
    const src=this.loops.get('bgm'); if(!src) return;
    this.fadeGain(this.gainBgm,this.gainBgm.gain.value,0.0,fade,()=>{
      try{ src.stop ? src.stop() : src.disconnect(); }catch(_){}
      this.loops.delete('bgm');
    });
  }
  fadeGain(node,from,to,secs,done){
    if(!this.ctx) return;
    const now=this.ctx.currentTime;
    try{
      node.gain.setValueAtTime(from,now);
      node.gain.linearRampToValueAtTime(to, now+secs);
    }catch(_){ node.gain.value=to; }
    if(done) setTimeout(done, secs*1000+10);
  }
  setMuted(m){
    this.enabled=!m;
    if(!this.ctx) return;
    this.gainMain.gain.value = m ? 0 : 0.9;
  }
}

/* ======= GAME (with joystick + overlay footer control) ======= */
(function(){
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');

  const siteFooter = document.getElementById('siteFooter');

  const consoleEl = document.querySelector('.console');
  const headEl = document.querySelector('.console-head');
  const footEl = document.querySelector('.console-foot');

  // Map modal elements
  const mapModal = document.getElementById('mapModal');
  const mapOpenBtn = document.getElementById('mapBtn');
  const mapCloseBtn = document.getElementById('mapClose');
  const mapTableBody = document.querySelector('#mapTable tbody');

  // Audio + controls
  const audio = new ReakAudio();
  const muteBtn = document.getElementById('muteBtn');

  // Grid config
  let COLS = 22, ROWS = 22;
  const isTouchDevice = ()=> matchMedia('(hover:none) and (pointer:coarse)').matches;
  const isDesktopFinePointer = ()=> matchMedia('(hover:hover) and (pointer:fine)').matches;
  function configureGrid(){ if(isTouchDevice()){ COLS=20; ROWS=20; } else { COLS=22; ROWS=22; } }
  configureGrid();

  // Colors
  const WALL='#172027', FLOOR='#0a0f13', PELLET='#9ee6b7', PLAYER='#3dff7a', RADIATION='#ff4d4d';

  // RNG
  const RAND_A=1664525, RAND_C=1013904223, RAND_M=4294967296;
  function makeRng(seed){ let s=seed>>>0; if(!s) s=0x1a2b3c4d; return ()=> ((s=(s*RAND_A+RAND_C)>>>0)/RAND_M); }

  // Levels
  const RADIO_LEVELS = [
    {rank:1,loc:'Fission Gardens',danger:'☣️',notes:'Overgrown and humming — deceptively calm.'},
    {rank:2,loc:'Glowworm Hall',danger:'☢️',notes:'Mild residual luminescence; stay under an hour.'},
    {rank:3,loc:'Iodine Vaults',danger:'☢️',notes:'Mostly stable isotopes… mostly.'},
    {rank:4,loc:'Helium Loop Junction',danger:'☣️',notes:'Low radiation, but pressure failures are brutal.'},
    {rank:5,loc:'Gamma Stairwell',danger:'☢️',notes:'Hot spots only near the landing lights.'},
    {rank:6,loc:'Turbine Catwalks',danger:'⚙️',notes:'More mechanical hazard than radioactive.'},
    {rank:7,loc:'Moderator Shaft',danger:'☢️',notes:'Beta radiation spikes during maintenance.'},
    {rank:8,loc:'Core Breach Gallery',danger:'☢️☢️',notes:'Faint blue Cherenkov glow — don’t linger.'},
    {rank:9,loc:'Hot Cell Annex',danger:'☢️☢️',notes:'Shielded, but glass cracks hum faintly.'},
    {rank:10,loc:'Cobalt Gallery',danger:'☢️☢️',notes:'Gamma haze dances across the walls.'},
    {rank:11,loc:'Decay Pools',danger:'☢️☢️',notes:'The water bubbles when you whisper.'},
    {rank:12,loc:'Bunker Delta-9',danger:'☢️☢️',notes:'Old reactor materials in containment. Allegedly.'},
    {rank:13,loc:'Neutron Spire',danger:'☢️☢️☢️',notes:'Constant low-frequency radiation pulses.'},
    {rank:14,loc:'The Half-Life Bridge',danger:'☢️☢️☢️',notes:'Crossing time correlates with lifespan.'},
    {rank:15,loc:'Coolant Cathedral',danger:'☢️☢️☢️',notes:'Echoes amplify Geiger ticks into hymns.'},
    {rank:16,loc:'The Exclusion Promenade',danger:'☢️☢️☢️',notes:'Banned zone for a reason. No birds.'},
    {rank:17,loc:'Control Rod Graveyard',danger:'☢️☢️☢️☢️',notes:'Spent fuel rods rust in open air.'},
    {rank:18,loc:'Sarcophagus Deep',danger:'☢️☢️☢️☢️',notes:'Beneath the concrete coffin — unstable readings.'},
    {rank:19,loc:'Plutonium Trench',danger:'☢️☢️☢️☢️',notes:'Lethal dust, heavy alpha scatter.'},
    {rank:20,loc:'Annihilation Deck',danger:'☢️☢️☢️☢️☢️',notes:'No readings. Just silence and light.'},
  ];
  function renderMapModal(){
    mapTableBody.innerHTML='';
    for(const row of RADIO_LEVELS){
      const tr=document.createElement('tr');
      tr.className='maprow';
      tr.innerHTML =
        '<td class="mapcell maprank">'+row.rank+'</td>'+
        '<td class="mapcell maploc">'+row.loc+'</td>'+
        '<td class="mapcell mapdanger">'+row.danger+'</td>'+
        '<td class="mapcell mapnotes">'+row.notes+'</td>';
      mapTableBody.appendChild(tr);
    }
  }
  function levelNameFor(n){ const i=Math.max(1,Math.min(20,n)); return `Rank ${i} — ${RADIO_LEVELS[i-1].loc}`; }

  // Map build
  let map=[], MCOLS=COLS, MROWS=ROWS, pelletsTotal=0;
  let runSeed=(Math.random()*0xffffffff)>>>0, mapNonce=0, pendingRunReset=true;
  function nextMapSeed(level){ mapNonce=(mapNonce+1)>>>0; return (runSeed ^ (level*0x9e3779b9) ^ (mapNonce*0x45d9f3b))>>>0; }
  function buildRawForLevel(n,seed){
    const rowsCount=ROWS, colsCount=COLS, rng=makeRng(seed>>>0);
    const grid=Array.from({length:rowsCount},()=>Array(colsCount).fill('1'));
    const stack=[[1,1]]; grid[1][1]='0';
    const carveDirs=[[2,0],[-2,0],[0,2],[0,-2]];
    while(stack.length){
      const [cx,cy]=stack[stack.length-1]; const neighbors=[];
      for(const [dx,dy] of carveDirs){
        const nx=cx+dx, ny=cy+dy;
        if(ny<=0||nx<=0||ny>=rowsCount-1||nx>=colsCount-1) continue;
        if(grid[ny][nx]!=='1') continue;
        neighbors.push([nx,ny,dx/2,dy/2]);
      }
      if(neighbors.length){
        const [nx,ny,wx,wy]=neighbors[Math.floor(rng()*neighbors.length)];
        grid[cy+wy][cx+wx]='0'; grid[ny][nx]='0'; stack.push([nx,ny]);
      }else stack.pop();
    }
    const loopDensity=isTouchDevice()?0.06:0.10;
    const extra=Math.floor((rowsCount*colsCount)*loopDensity);
    for(let i=0;i<extra;i++){
      const x=1+Math.floor(rng()*(colsCount-2)), y=1+Math.floor(rng()*(rowsCount-2));
      if(grid[y][x]!=='1') continue;
      let open=0;
      if(grid[y-1][x]!=='1') open++;
      if(grid[y+1][x]!=='1') open++;
      if(grid[y][x-1]!=='1') open++;
      if(grid[y][x+1]!=='1') open++;
      if(open>=2) grid[y][x]='0';
    }
    grid[1][2]='0'; grid[2][1]='0';
    grid[rowsCount-2][colsCount-2]='0';
    grid[rowsCount-2][colsCount-3]='0';
    grid[rowsCount-3][colsCount-2]='0';
    const spawn={x:1,y:1};
    const q=[[spawn.x,spawn.y,0]], visited=Array.from({length:rowsCount},()=>Array(colsCount).fill(false));
    visited[spawn.y][spawn.x]=true; let far={x:spawn.x,y:spawn.y,d:0};
    while(q.length){
      const [x,y,d]=q.shift(); if(d>far.d) far={x,y,d};
      for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx=x+dx, ny=y+dy;
        if(nx<=0||nx>=colsCount-1||ny<=0||ny>=rowsCount-1) continue;
        if(visited[ny][nx]) continue;
        if(grid[ny][nx]==='1') continue;
        visited[ny][nx]=true; q.push([nx,ny,d+1]);
      }
    }
    const farThreshold=isTouchDevice()?3:4;
    let exitPos= far.d>farThreshold ? far : spawn;
    if(exitPos.x===spawn.x && exitPos.y===spawn.y){
      outer: for(let y=rowsCount-2;y>0;y--){
        for(let x=colsCount-2;x>0;x--){
          if((x!==spawn.x||y!==spawn.y)&&grid[y][x]!=='1'){ exitPos={x,y,d:0}; break outer; }
        }
      }
    }
    grid[exitPos.y][exitPos.x]='3';
    let pelletCount=0, pelletP=isTouchDevice()?0.5:0.58;
    for(let y=1;y<rowsCount-1;y++){
      for(let x=1;x<colsCount-1;x++){
        if(grid[y][x]!=='0') continue;
        if(x===spawn.x && y===spawn.y) continue;
        if(rng()<pelletP){ grid[y][x]='2'; pelletCount++; }
      }
    }
    if(pelletCount===0){
      if(grid[spawn.y][spawn.x+1]==='0') grid[spawn.y][spawn.x+1]='2';
      else grid[spawn.y+1][spawn.x]='2';
    }
    return grid.map(r=>r.join(''));
  }
  function buildMapFromRaw(raw){
    const cols=raw[0].length, rows=raw.length, map=new Array(rows);
    for(let y=0;y<rows;y++){
      let line=raw[y]||''; if(line.length!==cols) line=(line+'1'.repeat(cols)).slice(0,cols);
      const rowArr=new Array(cols);
      for(let i=0;i<cols;i++){
        const ch=line[i]||'1';
        rowArr[i]=(ch==='1')?1 : (ch==='3')?3 : (ch==='.'||ch==='2')?2 : 0;
      }
      rowArr[0]=1; rowArr[cols-1]=1; map[y]=rowArr;
    }
    for(let x=0;x<cols;x++){ map[0][x]=1; map[rows-1][x]=1; }
    let exitPos=null; for(let y=1;y<rows-1;y++) for(let x=1;x<cols-1;x++) if(map[y][x]===3) exitPos={x,y};
    if(!exitPos){
      outer: for(let y=rows-3;y>=1;y--) for(let x=cols-3;x>=1;x--) if(map[y][x]!==1){ map[y][x]=3; exitPos={x,y}; break outer; }
    }
    let pellets=0; for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) if(map[y][x]===2) pellets++;
    if(pellets===0){
      for(let y=1;y<rows-1;y++) for(let x=1;x<cols-1;x++) if(map[y][x]===0&&((x+y)%2===0)) { map[y][x]=2; pellets++; }
    }
    pellets=0; for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) if(map[y][x]===2) pellets++;
    return {map, cols, rows, pellets};
  }
  function findPlayerSpawn(map,cols,rows){ for(let y=1;y<rows-1;y++) for(let x=1;x<cols-1;x++){ const c=map[y][x]; if(c!==1&&c!==3) return {x,y}; } return {x:1,y:1}; }
  function findHazardSpawn(map,cols,rows){ for(let y=rows-2;y>=1;y--) for(let x=cols-2;x>=1;x--){ const c=map[y][x]; if(c!==1&&c!==3) return {x,y}; } return {x:cols-2,y:rows-2}; }
  function ensureReachableExit(map,cols,rows,spawn){
    let exit=null; for(let y=1;y<rows-1;y++) for(let x=1;x<cols-1;x++) if(map[y][x]===3) exit={x,y};
    const key=(x,y)=>x+','+y; const q=[[spawn.x,spawn.y,0]]; const seen=new Set([key(spawn.x,spawn.y)]); let pathToExit=false; let far={x:spawn.x,y:spawn.y,d:0};
    while(q.length){
      const [x,y,d]=q.shift(); if(exit&&x===exit.x&&y===exit.y){ pathToExit=true; break; }
      if(d>far.d) far={x,y,d};
      for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx=x+dx, ny=y+dy; if(map[ny]?.[nx]!==1){
          const k=key(nx,ny); if(!seen.has(k)){ seen.add(k); q.push([nx,ny,d+1]); }
        }
      }
    }
    if(!pathToExit){ for(let y=1;y<rows-1;y++) for(let x=1;x<cols-1;x++) if(map[y][x]===3) map[y][x]=0; map[far.y][far.x]=3; }
  }

  // Entities & timing
  const BASE_PLAYER_DELAY=3, MIN_PLAYER_DELAY=2, BASE_RADIO_DELAY=9;
  const player={x:1,y:1,pellets:0,alive:false,stepDelay:BASE_PLAYER_DELAY,stepCooldown:0};
  let hazards=[];

  // UI
  const UI={
    menu:document.getElementById('menu'),
    menuTitle:document.getElementById('menuTitle'),
    menuSub:document.getElementById('menuSub'),
    play:document.getElementById('play'),
    score:document.getElementById('score'),
    status:document.getElementById('status'),
    levelName:document.getElementById('levelName'),
    countWrap:document.getElementById('count'),
    countNum:document.getElementById('countNum'),
    veil:document.getElementById('veil'),
    joyWrap:document.getElementById('joyWrap')
  };
  const DEFAULT_MENU_TITLE=UI.menuTitle.textContent, DEFAULT_MENU_SUB=UI.menuSub.innerHTML, DEFAULT_MENU_CTA=UI.play.textContent;

  let running=false, keyStartEnabled=true;

  // Input
  const keys=new Set();
  window.addEventListener('keydown', async e=>{
    keys.add(e.code);
    if(!running && keyStartEnabled && (e.code.startsWith('Arrow')||e.code.startsWith('Key'))){
      await audio.resume();
      startWithCountdown();
    }
  }, {passive:false});
  window.addEventListener('keyup', e=> keys.delete(e.code), {passive:true});

  // Mute
  let muted=false;
  document.getElementById('muteBtn').addEventListener('click', async ()=>{
    await audio.resume();
    muted=!muted; audio.setMuted(muted);
    muteBtn.textContent = muted ? '🔇' : '🔊';
    audio.play('ui_click', {gain:0.4, freq: muted?320:540});
  });

  function resetEntities(){
    player.pellets=0; player.stepCooldown=0; player.stepDelay=BASE_PLAYER_DELAY; player.alive=true;
    const pSpawn=findPlayerSpawn(map,MCOLS,MROWS); player.x=pSpawn.x; player.y=pSpawn.y;
    hazards=[]; const hazardCount=1+Math.floor((level-1)/2);
    const hSpawn=findHazardSpawn(map,MCOLS,MROWS);
    for(let i=0;i<hazardCount;i++){
      hazards.push({x:hSpawn.x,y:hSpawn.y,cooldown:0,base:Math.max(3, BASE_RADIO_DELAY - Math.min(level-1,4) - i)});
    }
    syncPlayerSpeed();
  }
  function syncPlayerSpeed(){ if(hazards.length){ player.stepDelay=Math.min(player.stepDelay,hazards[0].base); player.stepDelay=Math.max(MIN_PLAYER_DELAY,player.stepDelay); } }

  // Overlays (now control footer visibility here)
  function showOverlay(title,subtitle,cta,kind='menu'){
    if(UI.menu){
      UI.menu.classList.remove('cta--menu','cta--gameover','cta--victory');
      if(kind==='menu') UI.menu.classList.add('cta--menu');
      else if(kind==='gameover') UI.menu.classList.add('cta--gameover');
      else if(kind==='victory') UI.menu.classList.add('cta--victory');

      UI.menuTitle.textContent=title;
      UI.menuSub.innerHTML=subtitle;
      UI.play.textContent=cta;
      UI.veil.style.display='block';
      UI.menu.style.display='block';

      // Footer only on victory/gameover
      siteFooter.style.display = (kind==='victory' || kind==='gameover') ? 'block' : 'none';
    }
  }

  // Start / levels
  let level=1, score=0, high=parseInt(localStorage.getItem('reaktor404_high')||'0')||0;
  function startLevel(n){
    configureGrid(); MCOLS=COLS; MROWS=ROWS; level=n;

    const raw=buildRawForLevel(level, nextMapSeed(level));
    const built=buildMapFromRaw(raw);
    map=built.map; MCOLS=built.cols; MROWS=built.rows; pelletsTotal=built.pellets;

    const spawn=findPlayerSpawn(map,MCOLS,MROWS); ensureReachableExit(map,MCOLS,MROWS,spawn);
    document.getElementById('levelName').textContent=levelNameFor(level);
    resetEntities(); running=true; UI.veil.style.display='none'; UI.menu.style.display='none'; mapModal.style.display='none';
    siteFooter.style.display='none'; /* hide footer during gameplay */
    updateHUD(); sizeCanvasToConsole();

    audio.startBgm('bg_loop',0.6);
    audio.play('ui_open',{gain:0.35, freq:700});
    requestAnimationFrame(loop);
  }
  function start(){ startLevel(level); }

  async function startWithCountdown(){
    if(pendingRunReset){
      configureGrid(); score=0; level=1; player.pellets=0; pelletsTotal=0; map=[]; MCOLS=COLS; MROWS=ROWS;
      runSeed=(Math.random()*0xffffffff)>>>0; mapNonce=0; pendingRunReset=false;
      document.getElementById('levelName').textContent=levelNameFor(level);
      showOverlay(DEFAULT_MENU_TITLE, DEFAULT_MENU_SUB, DEFAULT_MENU_CTA, 'menu'); updateHUD();
    }
    keyStartEnabled=false; UI.menu.style.display='none'; UI.veil.style.display='none'; mapModal.style.display='none';
    siteFooter.style.display='none'; /* ensure hidden for countdown/gameplay */
    await audio.resume();
    let n=3; UI.countNum.textContent=n; UI.countWrap.style.display='flex';
    const step=()=>{
      audio.play('count_tick',{gain:0.4, freq:320+n*80});
      if(n<=1){ UI.countWrap.style.display='none'; start(); keyStartEnabled=true; return; }
      n--; UI.countNum.textContent=n; setTimeout(step,400);
    };
    setTimeout(step,500);
  }

  UI.play.addEventListener('click', async e=>{ e.preventDefault(); await audio.resume(); if(!running) startWithCountdown(); });

  // Map modal
  function openMap(){ renderMapModal(); UI.veil.style.display='block'; mapModal.style.display='block'; audio.play('ui_open',{gain:0.28, freq:640}); siteFooter.style.display='none'; }
  function closeMap(){ mapModal.style.display='none'; if(UI.menu.style.display!=='block') UI.veil.style.display='none'; audio.play('ui_click',{gain:0.28, freq:520}); }
  mapOpenBtn.addEventListener('click', async e=>{ e.preventDefault(); await audio.resume(); openMap(); });
  mapCloseBtn.addEventListener('click', e=>{ e.preventDefault(); closeMap(); });
  UI.veil.addEventListener('click', ()=>{ if(mapModal.style.display==='block' && UI.menu.style.display!=='block') closeMap(); });

  // Helpers
  const isWall=(x,y)=> map[y]?.[x]===1, isExit=(x,y)=> map[y]?.[x]===3;

  function updatePlayer(){
    if(player.stepCooldown>0){ player.stepCooldown--; return; }
    let dx=0, dy=0;
    if(keys.has('ArrowUp')||keys.has('KeyW')) dy=-1;
    else if(keys.has('ArrowDown')||keys.has('KeyS')) dy=1;
    else if(keys.has('ArrowLeft')||keys.has('KeyA')) dx=-1;
    else if(keys.has('ArrowRight')||keys.has('KeyD')) dx=1;

    if(dx||dy){
      const nx=player.x+dx, ny=player.y+dy;
      if(!isWall(nx,ny)){
        player.x=nx; player.y=ny; player.stepCooldown=player.stepDelay;
        audio.play('step',{gain:0.18, freq:220+((nx+ny)%3)*30, detune:((nx^ny)&1)?-50:0});
        if(map[ny][nx]===2){
          map[ny][nx]=0; player.pellets++; score+=10; flashPickup(nx,ny);
          audio.play('pickup',{gain:0.35, freq:880});
        }
        if(isExit(nx,ny)){
          score+=100; audio.play('exit',{gain:0.4, freq:520});
          nextLevel(); return;
        }
      }
    }
  }

  // FX
  let pickupFlash=0, fxPX=0, fxPY=0;
  function flashPickup(x,y){ pickupFlash=8; fxPX=x; fxPY=y; try{ navigator.vibrate&&navigator.vibrate(10); }catch(_){ } }

  // Enemies
  function stepHazards(){
    for(const h of hazards){
      if(h.cooldown>0){ h.cooldown--; continue; }
      h.cooldown=h.base;
      const q=[[h.x,h.y]], prev=new Map(), key=(x,y)=>x+","+y; prev.set(key(h.x,h.y),null);
      while(q.length){
        const [x,y]=q.shift(); if(x===player.x&&y===player.y) break;
        for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=x+dx, ny=y+dy, cell=map[ny]?.[nx];
          if(cell!==1 && !prev.has(key(nx,ny))){ prev.set(key(nx,ny),[x,y]); q.push([nx,ny]); }
        }
      }
      let cur=[player.x,player.y]; if(!prev.has(key(cur[0],cur[1]))) continue;
      while(prev.get(key(cur[0],cur[1])) && !(prev.get(key(cur[0],cur[1]))[0]===h.x && prev.get(key(cur[0],cur[1]))[1]===h.y)) cur=prev.get(key(cur[0],cur[1]));
      if(cur){ h.x=cur[0]; h.y=cur[1]; }
    }
  }

  function collide(){
    if(isExit(player.x,player.y)) return false;
    for(const h of hazards){ if(h.x===player.x && h.y===player.y){ deathScreen(); return true; } }
    return false;
  }

  function deathScreen(){
    running=false; player.alive=false;
    if(score>high){ high=score; localStorage.setItem('reaktor404_high', String(high)); }
    const sub=`Sample collected.<br/>Seals ${player.pellets}/${pelletsTotal} | Score ${score} | ${levelNameFor(level)}<br/>High ${high}`;
    showOverlay('DECONTAMINATION SUCCESSFUL', sub, 'Restart Run', 'victory'); // using victory style text
    audio.play('death',{gain:0.45, freq:200});
    audio.stopBgm(0.4);
    pendingRunReset=true;
    keyStartEnabled=false; setTimeout(()=>{ keyStartEnabled=true; },1200);
  }

  function nextLevel(){
    running=false;
    if(score>high){ high=score; localStorage.setItem('reaktor404_high', String(high)); }
    if(level>=20){
      const sub=`All 20 ranks cleared.<br/>Run score ${score} | High ${high}`;
      showOverlay('CONTAINMENT SECURED', sub, 'Restart Run', 'victory');
      audio.stopBgm(0.5);
      pendingRunReset=true; player.pellets=0; player.alive=false;
      keyStartEnabled=false; setTimeout(()=>{ keyStartEnabled=true; },600);
      return;
    }
    const sub=`${levelNameFor(level)} complete | Seals ${player.pellets}/${pelletsTotal} | Score ${score}<br/>High ${high}`;
    showOverlay('SECTOR CLEARED', sub, 'Next Sector', 'victory');
    audio.stopBgm(0.35);
    level++; player.pellets=0;
    keyStartEnabled=false; setTimeout(()=>{ keyStartEnabled=true; },400);
  }

  function updateHUD(){
    document.getElementById('levelName').textContent=levelNameFor(level);
    UI.score.textContent=`Seals: ${player.pellets}/${pelletsTotal} | Score: ${score} | L${level}`;
  }

  // Draw
  let drawTick=0;
  function draw(){
    const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1));
    const cssW=cvs.clientWidth|0, cssH=cvs.clientHeight|0;
    if(cvs.width!==cssW*dpr || cvs.height!==cssH*dpr){ cvs.width=cssW*dpr; cvs.height=cssH*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); }
    drawTick++;
    ctx.fillStyle=FLOOR; ctx.fillRect(0,0,cssW,cssH);
    const cell=Math.floor(Math.min(cssW,cssH)/COLS);
    const offX=Math.floor((cssW-cell*COLS)/2), offY=Math.floor((cssH-cell*ROWS)/2);
    for(let y=0;y<MROWS;y++){
      for(let x=0;x<MCOLS;x++){
        const c=map[y][x], px=offX+x*cell, py=offY+y*cell;
        if(c===1){ ctx.fillStyle=WALL; ctx.fillRect(px,py,cell,cell); ctx.fillStyle='rgba(61,255,122,.05)'; ctx.fillRect(px+2,py+2,cell-4,cell-4); }
        else if(c===2){ ctx.fillStyle=PELLET; const s=Math.max(3,Math.floor(cell*0.25)); const pad=(cell-s)>>1; ctx.fillRect(px+pad,py+pad,s,s); }
        else if(c===3){ const a=0.6+0.35*Math.sin(drawTick*0.1); ctx.fillStyle=`rgba(255,211,77,${a})`; const s=Math.max(6,Math.floor(cell*0.6)); const pad=(cell-s)>>1; ctx.fillRect(px+pad,py+pad,s,s); }
      }
    }
    if(pickupFlash>0){
      const px=offX+fxPX*cell, py=offY+fxPY*cell;
      ctx.strokeStyle='rgba(157,255,197,.9)'; ctx.lineWidth=1;
      const pad=Math.max(2,Math.floor(cell*0.15));
      ctx.strokeRect(px+pad-pickupFlash/2, py+pad-pickupFlash/2, cell-2*pad+pickupFlash, cell-2*pad+pickupFlash); pickupFlash--;
    }
    ctx.fillStyle=PLAYER; const ppx=offX+player.x*cell, ppy=offY+player.y*cell;
    ctx.fillRect(ppx+Math.floor(cell*0.18), ppy+Math.floor(cell*0.18), Math.floor(cell*0.64), Math.floor(cell*0.64));
    for(const h of hazards){
      const gx=offX+h.x*cell, gy=offY+h.y*cell;
      ctx.fillStyle=RADIATION; ctx.fillRect(gx+Math.floor(cell*0.12), gy+Math.floor(cell*0.12), Math.floor(cell*0.76), Math.floor(cell*0.76));
      ctx.fillStyle='#111'; const eye=Math.max(2,Math.floor(cell*0.16));
      ctx.fillRect(gx+Math.floor(cell*0.28), gy+Math.floor(cell*0.34), eye, eye);
      ctx.fillRect(gx+Math.floor(cell*0.64), gy+Math.floor(cell*0.34), eye, eye);
    }
  }

  function loop(){
    if(!running) return;
    updatePlayer(); if(!running){ updateHUD(); draw(); return; }
    stepHazards(); if(!running) return;
    if(collide()){ updateHUD(); draw(); return; }
    updateHUD(); draw(); requestAnimationFrame(loop);
  }

  // Self-test (unchanged)
  (function selfTest(){
    const errs=[];
    for(let i=1;i<=4;i++){
      const raw=buildRawForLevel(i,(i*0x9e3779b9)>>>0);
      const cols=raw[0].length; raw.forEach((row,ri)=>{ if(row.length!==cols) errs.push(`Lvl ${i} row ${ri+1} width ${row.length} != ${cols}`); });
      const b=buildMapFromRaw(raw);
      const spawn=findPlayerSpawn(b.map,b.cols,b.rows);
      ensureReachableExit(b.map,b.cols,b.rows,spawn);
      let hasExit=false; for(let y=1;y<b.rows-1;y++) for(let x=1;x<b.cols-1;x++) if(b.map[y][x]===3) hasExit=true; if(!hasExit) errs.push('No interior exit in level '+i);
      let pel=0; for(let y=0;y<b.rows;y++) for(let x=0;x<b.cols;x++) if(b.map[y][x]===2) pel++; if(pel<=0) errs.push('No seals in level '+i);
      const key=(x,y)=>x+','+y; const q=[[spawn.x,spawn.y]]; const seen=new Set([key(spawn.x,spawn.y)]); let ex=null; for(let yy=1;yy<b.rows-1;yy++) for(let xx=1;xx<b.cols-1;xx++) if(b.map[yy][xx]===3) ex={x:xx,y:yy};
      let canExit=false; while(q.length){ const [x,y]=q.shift(); if(ex&&x===ex.x&&y===ex.y){ canExit=true; break; }
        for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=x+dx, ny=y+dy; if(b.map[ny]?.[nx]!==1){ const k=key(nx,ny); if(!seen.has(k)){ seen.add(k); q.push([nx,ny]); } } }
    }
    if(!canExit) errs.push('Exit unreachable in level '+i);
    }
    if(!(BASE_PLAYER_DELAY>=1 && MIN_PLAYER_DELAY>=1 && BASE_PLAYER_DELAY>=MIN_PLAYER_DELAY)) errs.push('Invalid player step timing');
    if(!(BASE_RADIO_DELAY>=2)) errs.push('Invalid hazard timing');
    if(errs.length){ console.error('[Reaktor 404 self-test FAIL]', errs); throw new Error('[Reaktor 404 self-test FAIL]'); }
    else { console.log('[Reaktor 404 self-test PASS]'); }
  })();

  // Initial overlay
  (function showStart(){
    document.getElementById('veil').style.display='block';
    siteFooter.style.display='none'; // hidden on menu by default
    showOverlay('REAKTOR 404', document.getElementById('menuSub').innerHTML, 'Start', 'menu');
  })();

  // Canvas sizing
  function sizeCanvasToConsole(){
    if(!isDesktopFinePointer()){ cvs.style.width='100%'; cvs.style.height='auto'; return; }
    const pad=10*2, headH=headEl.getBoundingClientRect().height, footH=footEl.getBoundingClientRect().height;
    const availableW=Math.floor(consoleEl.clientWidth-0), availableH=Math.floor(window.innerHeight-headH-footH-32);
    const MIN_DESK=420, MAX_DESK=720, target=Math.floor(window.innerHeight*0.72);
    const size=Math.max(MIN_DESK, Math.min(MAX_DESK, target, availableW-pad, availableH-pad));
    cvs.style.width=size+'px'; cvs.style.height=size+'px';
  }
  window.addEventListener('resize', sizeCanvasToConsole);
  window.addEventListener('orientationchange', sizeCanvasToConsole);
  requestAnimationFrame(sizeCanvasToConsole);

  /* ===== ANALOG JOYSTICK (mobile) ===== */
  (function setupJoystick(){
    const isTouch = matchMedia('(hover:none) and (pointer:coarse)').matches;
    const wrap = document.getElementById('joyWrap');
    const joy = document.getElementById('joystick');
    const knob = document.getElementById('joyKnob');
    if(!isTouch || !joy) { if(wrap) wrap.style.display='none'; return; }

    const dirKey = {up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight'};
    let pointerId=null;

    const dead = 10; // px deadzone
    const maxR = () => (joy.clientWidth * 0.38); // knob travel radius

    function setDirFrom(dx, dy){
      const ax=Math.abs(dx), ay=Math.abs(dy);
      const withinDead = (Math.hypot(dx,dy) < dead);
      Object.values(dirKey).forEach(k=> keys.delete(k));
      if(withinDead) return;
      if(ax > ay){ keys.add(dx>0 ? dirKey.right : dirKey.left); }
      else{ keys.add(dy>0 ? dirKey.down : dirKey.up); }
    }

    function placeKnob(dx,dy){
      const rMax=maxR(), mag=Math.hypot(dx,dy), scale=mag>rMax ? (rMax/mag) : 1;
      const x=dx*scale, y=dy*scale;
      knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
    }
    function centerKnob(){ knob.style.transform='translate(-50%,-50%)'; }

    joy.addEventListener('pointerdown', async (e)=>{
      pointerId=e.pointerId;
      try{ joy.setPointerCapture(pointerId); }catch(_){}
      await audio.resume();
      e.preventDefault();
    }, {passive:false});

    joy.addEventListener('pointermove', (e)=>{
      if(e.pointerId!==pointerId) return;
      const rect=joy.getBoundingClientRect();
      const dx=e.clientX-(rect.left+rect.width/2);
      const dy=e.clientY-(rect.top+rect.height/2);
      placeKnob(dx,dy); setDirFrom(dx,dy);
      e.preventDefault();
    }, {passive:false});

    function end(){
      pointerId=null;
      Object.values(dirKey).forEach(k=> keys.delete(k));
      centerKnob();
    }
    joy.addEventListener('pointerup',    e=>{ if(e.pointerId!==pointerId) return; end(); e.preventDefault(); }, {passive:false});
    joy.addEventListener('pointercancel',e=>{ if(e.pointerId!==pointerId) return; end(); e.preventDefault(); }, {passive:false});
    joy.addEventListener('pointerleave', e=>{ if(e.pointerId!==pointerId) return; end(); e.preventDefault(); }, {passive:false});

    // Tap joystick to start run/audio
    joy.addEventListener('pointerdown', async ()=>{
      if(!running && keyStartEnabled){ await audio.resume(); startWithCountdown(); }
    }, {passive:true});
  })();

  // Tap-to-move on canvas + start on tap
  (function setupTapMove(){
    const pressOnce = (code)=>{ keys.add(code); try{ navigator.vibrate&&navigator.vibrate(6); }catch(_){ } setTimeout(()=> keys.delete(code), 60); };
    const handleTap = (clientX, clientY)=>{
      const cssW=cvs.clientWidth|0, cssH=cvs.clientHeight|0;
      const cell=Math.floor(Math.min(cssW,cssH)/COLS);
      const offX=Math.floor((cssW-cell*COLS)/2), offY=Math.floor((cssH-cell*ROWS)/2);
      const rect=cvs.getBoundingClientRect();
      const x=clientX-rect.left, y=clientY-rect.top;
      const ppx=offX+(player.x+.5)*cell, ppy=offY+(player.y+.5)*cell;
      const dx=x-ppx, dy=y-ppy;
      if(Math.abs(dx)>Math.abs(dy)) pressOnce(dx>0?'ArrowRight':'ArrowLeft');
      else pressOnce(dy>0?'ArrowDown':'ArrowUp');
    };
    cvs.addEventListener('pointerup', async e=>{
      if(e.pointerType==='mouse'||e.pointerType==='touch'){ await audio.resume(); handleTap(e.clientX,e.clientY); e.preventDefault(); }
    }, {passive:false});
    cvs.addEventListener('pointerdown', async e=>{
      if(!running && keyStartEnabled){ await audio.resume(); startWithCountdown(); }
    }, {passive:true});
  })();

})(); // end IIFE
</script>
</body>
</html>
